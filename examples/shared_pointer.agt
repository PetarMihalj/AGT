struct shared_ptr<T>{
    let item_ptr = @T;
    let count = @i32;
}

fn __init__(sptr_ptr, item_ptr){
    type T = enable_if_resolve<sptr_ptr!.T>;
    type _ = enable_if<sptr_ptr == @shared_ptr<T>>;
    type _ = enable_if<item_ptr == @T>;

    sptr_ptr!.item_ptr = item_ptr;
    sptr_ptr!.count = heap_object<i32>(1);
}

fn __dest__(sptr_ptr){
    type T = enable_if_resolve<sptr_ptr!.T>;
    type _ = enable_if<sptr_ptr == @shared_ptr<T>>;

    sptr_ptr!.count! = sptr_ptr!.count! - 1;
    /*if (sptr_ptr!.count! == 1){
        heap_free<T>(sptr_ptr!.item_ptr);
        //heap_free<i32>(sptr_ptr!.count);
    }*/
}

fn __copy__(sptr_ptr_dest, sptr_ptr_src){
    type T = enable_if_resolve<sptr_ptr_dest!.T>;
    type _ = enable_if<sptr_ptr_dest == @shared_ptr<T>>;
    type _ = enable_if<sptr_ptr_src == @shared_ptr<T>>;

    sptr_ptr_src!.count! = sptr_ptr_src!.count! + 1;

    sptr_ptr_dest!.item_ptr = sptr_ptr_src!.item_ptr;
    sptr_ptr_dest!.count = sptr_ptr_src!.count;
}

fn main() -> i32{
    let a = object<shared_ptr<i8>>(heap_object<i8>(15i8));
    out(1000000);
    out(a.count!);
    out(a.item_ptr!);
    {
        let b = a;
        out(1000000);
        out(a.count!);
        out(a.item_ptr!);
        out(b.count!);
        out(b.item_ptr!);
        b.item_ptr! = 13i8;
        out(1000000);
        out(a.count!);
        out(a.item_ptr!);
        out(b.count!);
        out(b.item_ptr!);
    }
    out(1000000);
    out(a.count!);
    out(a.item_ptr!);

    return 0;
}
