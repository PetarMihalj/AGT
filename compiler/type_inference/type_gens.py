from typing import List

from .type_system import Type
from ..helpers import add_method_to_list
from . import type_system as ts
from .recursive_logger import LogTypes

from ..semantics_parsing import semantic_ast as sa
# MAIN METHODS

func_methods = []
struct_methods = []

def gen_function(tc, name: str,
                 type_argument_types: List[Type],
                 argument_types: List[Type]
            ):
    if ((name, tuple(type_argument_types), tuple(argument_types))) in tc.gen_set:
        return
    tc.gen_set.add((name, tuple(type_argument_types), tuple(argument_types)))
    for sm in func_methods:
        if sm(tc,name,type_argument_types, argument_types):
            tc.logger.log("Function def autogenerated", LogTypes.FUNCTION_OR_STRUCT_DEFINITION)

def gen_struct(tc, name: str,
            type_argument_types: List[Type]
        ):
    if ((name, tuple(type_argument_types))) in tc.gen_set:
        return
    tc.gen_set.add((name, tuple(type_argument_types))) 
    for sm in struct_methods:
        if sm(tc,name,type_argument_types):
            tc.logger.log("Struct def autogenerated", LogTypes.FUNCTION_OR_STRUCT_DEFINITION)

# targets

@add_method_to_list(struct_methods)
def gen_void(tc, name: str,
                 type_argument_types: List[Type],
            ):
    if name == "void" and len(type_argument_types)==0:
        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.VoidType()
        return True
    else:
        return False


@add_method_to_list(struct_methods)
def gen_int(tc, name: str,
                 type_argument_types: List[Type],
            ):
    try:
        if name[0] == 'i':
            sign = 1
        elif name[0] == 'I':
            sign = -1
        else:
            return False
        val = int(name[1:])*sign

        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.IntType(val)
        return True
    except:
        return False


@add_method_to_list(struct_methods)
def gen_int_ops(tc, name: str,
                 type_argument_types: List[Type],
            ):
    try:
        i1 = type_argument_types[0].size
        i2 = type_argument_types[1].size
        res = int(getattr(i1, name if name!="__div__" else "__floordiv__")(i2))
        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.IntType(res)
        return True
    except:
        return False

##
##
## functions
##
##

@add_method_to_list(func_methods)
def gen_int_init_default(tc, name: str,
                         type_argument_types: List[Type],
                         argument_types: List[Type],
            ):
    if name != "__init__": return False
    if len(type_argument_types)>0: return False

    if len(argument_types) != 1: return False
    if not isinstance(argument_types[0], ts.PointerType): return False
    pointed = argument_types[0].pointed
    if not isinstance(pointed, ts.IntType): return False
    size = pointed.size
    if size <= 0: return False

    f = sa.FunctionDefinition(
        "__init__",
        [],
        ["ptr"],
        sa.TypeIdExpression("void"),
        [
            sa.InitStatement("lv", sa.DerefExpression(sa.IdExpression("ptr"))),
            sa.AssignmentStatement(sa.IdExpression("lv"), sa.IntLiteralExpression(0, size))
        ]
    )
    f.linespan = (-1,-1)
    f.lexspan = (-1,-1)
    tc.func_defs.append(f)
    return True

@add_method_to_list(func_methods)
def gen_int_dest_default(tc, name: str,
                         type_argument_types: List[Type],
                         argument_types: List[Type],
            ):
    if name != "__dest__": return False
    if len(type_argument_types)>0: return False

    if len(argument_types) != 1: return False
    if not isinstance(argument_types[0], ts.PointerType): return False
    pointed = argument_types[0].pointed
    if not isinstance(pointed, ts.IntType): return False
    size = pointed.size
    if size <= 0: return False

    f = sa.FunctionDefinition(
        "__init__",
        [],
        ["ptr"],
        sa.TypeIdExpression("void"),
        [
        ]
    )
    f.linespan = (-1,-1)
    f.lexspan = (-1,-1)
    tc.func_defs.append(f)
    return True


@add_method_to_list(func_methods)
def gen_int_copy_default(tc, name: str,
                         type_argument_types: List[Type],
                         argument_types: List[Type],
            ):
    if name != "__copy__": return False
    if len(type_argument_types)>0: return False

    if len(argument_types) != 2: return False

    if not isinstance(argument_types[0], ts.PointerType): return False
    pointed1 = argument_types[0].pointed
    if not isinstance(pointed1, ts.IntType): return False
    size1 = pointed.size
    if size1 <= 0: return False


    if not isinstance(argument_types[1], ts.PointerType): return False
    pointed2 = argument_types[1].pointed
    if not isinstance(pointed2, ts.IntType): return False
    size2 = pointed.size
    if size2 <= 0: return False

    if size1 != size2:
        return False

    f = sa.FunctionDefinition(
        "__init__",
        [],
        ["ptr"],
        sa.TypeIdExpression("void"),
        [
            sa.MemoryCopyStatement(pointed1, pointer2)
        ]
    )
    f.linespan = (-1,-1)
    f.lexspan = (-1,-1)
    tc.func_defs.append(f)
    return True


@add_method_to_list(struct_methods)
def gen_int_ops(tc, name: str,
                 type_argument_types: List[Type],
            ):
    try:
        i1 = type_argument_types[0].size
        i2 = type_argument_types[1].size
        res = int(getattr(i1, name if name!="__div__" else "__floordiv__")(i2))
        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.IntType(res)
        return True
    except:
        return False


@add_method_to_list(func_methods)
def gen_type_to_value(tc, name: str,
                         type_argument_types: List[Type],
                         argument_types: List[Type],
            ):
    if name != "type_to_value": return False
    if len(argument_types)>0: return False

    if len(type_argument_types) != 2: return False

    if not isinstance(type_argument_types[0], ts.IntType): return False
    if not isinstance(type_argument_types[1], ts.IntType): return False
    val = type_argument_types[0].size
    size = type_argument_types[1].size


    f = sa.FunctionDefinition(
        "type_to_value",
        type_argument_types,
        [],
        sa.TypeIdExpression(f"i{size}"),
        [
            sa.ReturnStatement(sa.IntLiteralExpression(val, size))
        ]
    )
    f.linespan = (-1,-1)
    f.lexspan = (-1,-1)
    tc.func_defs.append(f)
    return True
