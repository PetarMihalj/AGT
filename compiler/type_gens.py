from type_system import Type
from helpers import add_method_to_list
from typing import List
import type_system as ts
from type_system import LogTypes
# MAIN METHODS

func_methods = []
struct_methods = []

def gen_function(tc, name: str,
                 type_argument_types: List[Type],
                 argument_types: List[Type]
            ):
    #tc.logger.log("Function def autogenerated", LogTypes.FUNCTION_OR_STRUCT_DEFINITION)
    return False

def gen_struct(tc, name: str,
            type_argument_types: List[Type]
        ):
    for sm in struct_methods:
        if sm(tc,name,type_argument_types):
            tc.logger.log("Struct def autogenerated", LogTypes.FUNCTION_OR_STRUCT_DEFINITION)
            return True
    return False

# targets

@add_method_to_list(struct_methods)
def gen_void(tc, name: str,
                 type_argument_types: List[Type],
            ):
    if name == "void" and len(type_argument_types)==0:
        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.VoidType()
        return True
    else:
        return False


@add_method_to_list(struct_methods)
def gen_int(tc, name: str,
                 type_argument_types: List[Type],
            ):
    try:
        if name[0] == 'i':
            sign = 1
        elif name[0] == 'I':
            sign = -1
        else:
            return False
        val = int(name[1:])*sign

        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.IntType(val)
        return True
    except:
        return False

import semantic_ast

@add_method_to_list(struct_methods)
def gen_int_ops(tc, name: str,
                 type_argument_types: List[Type],
            ):
    try:
        i1 = type_argument_types[0].size
        i2 = type_argument_types[1].size
        res = int(getattr(i1, name if name!="__div__" else "__floordiv__")(i2))
        tc.struct_type_container[(name, tuple(type_argument_types))] = ts.IntType(res)
        return True
    except:
        return False
