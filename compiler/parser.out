Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> CompilationUnit
Rule 1     AddressExpression -> AMPERSAND Expression
Rule 2     Argument -> Expression
Rule 3     ArgumentListR -> Argument COMMA ArgumentListR
Rule 4     ArgumentListR -> Argument
Rule 5     ArgumentListR -> empty
Rule 6     AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON
Rule 7     AssignmentStatement -> Expression ASSIGNMENT Expression
Rule 8     BinaryExpression -> Expression PLUS Expression
Rule 9     BinaryExpression -> Expression MINUS Expression
Rule 10    BinaryExpression -> Expression TIMES Expression
Rule 11    BinaryExpression -> Expression DIVIDE Expression
Rule 12    BinaryExpression -> Expression MOD Expression
Rule 13    BinaryExpression -> Expression LEQ Expression
Rule 14    BinaryExpression -> Expression GEQ Expression
Rule 15    BinaryExpression -> Expression LT Expression
Rule 16    BinaryExpression -> Expression GT Expression
Rule 17    BinaryExpression -> Expression EQ Expression
Rule 18    BinaryExpression -> Expression NE Expression
Rule 19    BlankStatement -> ;
Rule 20    Block -> LBRACE StatementListR RBRACE
Rule 21    BlockStatement -> Block
Rule 22    BoolLiteral -> BOOLL
Rule 23    BracketCall -> Expression LBRACKET Expression RBRACKET
Rule 24    BreakStatement -> BREAK INTL SEMICOLON
Rule 25    BreakStatement -> BREAK SEMICOLON
Rule 26    CompilationUnit -> DefinitionListR
Rule 27    DefinitionListR -> FunctionDefinition DefinitionListR
Rule 28    DefinitionListR -> StructDefinition DefinitionListR
Rule 29    DefinitionListR -> empty
Rule 30    DereferenceExpression -> TIMES Expression
Rule 31    Expression -> BinaryExpression
Rule 32    Expression -> UnaryExpression
Rule 33    Expression -> IdExpression
Rule 34    ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block
Rule 35    FunctionCall -> ID LPAREN ArgumentListR RPAREN
Rule 36    FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
Rule 37    FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN Block
Rule 38    FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block
Rule 39    IdExpression -> ID
Rule 40    IdExpression -> IdExpression DOT ID
Rule 41    IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block
Rule 42    InitCall -> ID LBRACE ArgumentListR RBRACE
Rule 43    InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
Rule 44    InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON
Rule 45    IntLiteral -> INTL
Rule 46    Literal -> IntLiteral
Rule 47    Literal -> BoolLiteral
Rule 48    Parameter -> Type ID
Rule 49    ParameterListR -> Parameter COMMA ParameterListR
Rule 50    ParameterListR -> Parameter
Rule 51    ParameterListR -> empty
Rule 52    PointerListR -> TIMES PointerListR
Rule 53    PointerListR -> empty
Rule 54    ReturnStatement -> RETURN Expression SEMICOLON
Rule 55    ReturnStatement -> RETURN SEMICOLON
Rule 56    Statement -> AssignmentStatement
Rule 57    Statement -> InitStatement
Rule 58    Statement -> Expression SEMICOLON
Rule 59    Statement -> IfElseStatement
Rule 60    Statement -> ForStatement
Rule 61    Statement -> WhileStatement
Rule 62    Statement -> BreakStatement
Rule 63    Statement -> ReturnStatement
Rule 64    Statement -> BlockStatement
Rule 65    Statement -> BlankStatement
Rule 66    StatementListR -> Statement StatementListR
Rule 67    StatementListR -> empty
Rule 68    StructDefinition -> STRUCT ID LBRACE StructMemberListR RBRACE
Rule 69    StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE
Rule 70    StructMember -> Type ID SEMICOLON
Rule 71    StructMemberListR -> StructMember StructMemberListR
Rule 72    StructMemberListR -> empty
Rule 73    Type -> ID PointerListR
Rule 74    Type -> ID LT TypeArgumentListR GT PointerListR
Rule 75    TypeArgumentListR -> Type COMMA TypeArgumentListR
Rule 76    TypeArgumentListR -> Type
Rule 77    TypeArgumentListR -> empty
Rule 78    TypeParameterListR -> ID COMMA TypeParameterListR
Rule 79    TypeParameterListR -> ID
Rule 80    TypeParameterListR -> empty
Rule 81    UnaryExpression -> Literal
Rule 82    UnaryExpression -> FunctionCall
Rule 83    UnaryExpression -> BracketCall
Rule 84    UnaryExpression -> InitCall
Rule 85    UnaryExpression -> LPAREN Expression RPAREN
Rule 86    UnaryExpression -> DereferenceExpression
Rule 87    UnaryExpression -> AddressExpression
Rule 88    WhileStatement -> WHILE LPAREN Expression RPAREN Block
Rule 89    empty -> <empty>

Terminals, with rules where they appear

;                    : 19
AMPERSAND            : 1
ASSIGNMENT           : 6 7 44
BOOLL                : 22
BREAK                : 24 25
COMMA                : 3 49 75 78
DIVIDE               : 11
DOT                  : 40
ELSE                 : 41
EQ                   : 17
FN                   : 37 38
FOR                  : 34
GEQ                  : 14
GT                   : 16 36 38 43 69 74
ID                   : 35 36 37 38 39 40 42 43 44 48 68 69 70 73 74 78 79
IF                   : 41
INTL                 : 24 45
LBRACE               : 20 42 43 68 69
LBRACKET             : 23
LEQ                  : 13
LET                  : 44
LPAREN               : 34 35 36 37 38 41 85 88
LT                   : 15 36 38 43 69 74
MINUS                : 9
MOD                  : 12
NE                   : 18
PLUS                 : 8
RBRACE               : 20 42 43 68 69
RBRACKET             : 23
RETURN               : 54 55
RPAREN               : 34 35 36 37 38 41 85 88
SEMICOLON            : 6 24 25 34 44 54 55 58 70
STRUCT               : 68 69
TIMES                : 10 30 52
WHILE                : 88
error                : 

Nonterminals, with rules where they appear

AddressExpression    : 87
Argument             : 3 4
ArgumentListR        : 3 35 36 42 43
AssignmentStatement  : 56
BinaryExpression     : 31
BlankStatement       : 65
Block                : 21 34 37 38 41 41 88
BlockStatement       : 64
BoolLiteral          : 47
BracketCall          : 83
BreakStatement       : 62
CompilationUnit      : 0
DefinitionListR      : 26 27 28
DereferenceExpression : 86
Expression           : 1 2 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15 16 16 17 17 18 18 23 23 30 34 41 54 58 85 88
ForStatement         : 60
FunctionCall         : 82
FunctionDefinition   : 27
IdExpression         : 33 40
IfElseStatement      : 59
InitCall             : 44 84
InitStatement        : 57
IntLiteral           : 46
Literal              : 81
Parameter            : 49 50
ParameterListR       : 37 38 49
PointerListR         : 52 73 74
ReturnStatement      : 63
Statement            : 34 34 66
StatementListR       : 20 66
StructDefinition     : 28
StructMember         : 71
StructMemberListR    : 68 69 71
Type                 : 48 70 75 76
TypeArgumentListR    : 36 43 74 75
TypeParameterListR   : 38 69 78
UnaryExpression      : 32
WhileStatement       : 61
empty                : 5 29 51 53 67 72 77 80

Parsing method: LALR

state 0

    (0) S' -> . CompilationUnit
    (26) CompilationUnit -> . DefinitionListR
    (27) DefinitionListR -> . FunctionDefinition DefinitionListR
    (28) DefinitionListR -> . StructDefinition DefinitionListR
    (29) DefinitionListR -> . empty
    (37) FunctionDefinition -> . FN ID LPAREN ParameterListR RPAREN Block
    (38) FunctionDefinition -> . FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block
    (68) StructDefinition -> . STRUCT ID LBRACE StructMemberListR RBRACE
    (69) StructDefinition -> . STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE
    (89) empty -> .

    FN              shift and go to state 6
    STRUCT          shift and go to state 7
    $end            reduce using rule 89 (empty -> .)

    CompilationUnit                shift and go to state 1
    DefinitionListR                shift and go to state 2
    FunctionDefinition             shift and go to state 3
    StructDefinition               shift and go to state 4
    empty                          shift and go to state 5

state 1

    (0) S' -> CompilationUnit .



state 2

    (26) CompilationUnit -> DefinitionListR .

    $end            reduce using rule 26 (CompilationUnit -> DefinitionListR .)


state 3

    (27) DefinitionListR -> FunctionDefinition . DefinitionListR
    (27) DefinitionListR -> . FunctionDefinition DefinitionListR
    (28) DefinitionListR -> . StructDefinition DefinitionListR
    (29) DefinitionListR -> . empty
    (37) FunctionDefinition -> . FN ID LPAREN ParameterListR RPAREN Block
    (38) FunctionDefinition -> . FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block
    (68) StructDefinition -> . STRUCT ID LBRACE StructMemberListR RBRACE
    (69) StructDefinition -> . STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE
    (89) empty -> .

    FN              shift and go to state 6
    STRUCT          shift and go to state 7
    $end            reduce using rule 89 (empty -> .)

    FunctionDefinition             shift and go to state 3
    DefinitionListR                shift and go to state 8
    StructDefinition               shift and go to state 4
    empty                          shift and go to state 5

state 4

    (28) DefinitionListR -> StructDefinition . DefinitionListR
    (27) DefinitionListR -> . FunctionDefinition DefinitionListR
    (28) DefinitionListR -> . StructDefinition DefinitionListR
    (29) DefinitionListR -> . empty
    (37) FunctionDefinition -> . FN ID LPAREN ParameterListR RPAREN Block
    (38) FunctionDefinition -> . FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block
    (68) StructDefinition -> . STRUCT ID LBRACE StructMemberListR RBRACE
    (69) StructDefinition -> . STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE
    (89) empty -> .

    FN              shift and go to state 6
    STRUCT          shift and go to state 7
    $end            reduce using rule 89 (empty -> .)

    StructDefinition               shift and go to state 4
    DefinitionListR                shift and go to state 9
    FunctionDefinition             shift and go to state 3
    empty                          shift and go to state 5

state 5

    (29) DefinitionListR -> empty .

    $end            reduce using rule 29 (DefinitionListR -> empty .)


state 6

    (37) FunctionDefinition -> FN . ID LPAREN ParameterListR RPAREN Block
    (38) FunctionDefinition -> FN . ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block

    ID              shift and go to state 10


state 7

    (68) StructDefinition -> STRUCT . ID LBRACE StructMemberListR RBRACE
    (69) StructDefinition -> STRUCT . ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE

    ID              shift and go to state 11


state 8

    (27) DefinitionListR -> FunctionDefinition DefinitionListR .

    $end            reduce using rule 27 (DefinitionListR -> FunctionDefinition DefinitionListR .)


state 9

    (28) DefinitionListR -> StructDefinition DefinitionListR .

    $end            reduce using rule 28 (DefinitionListR -> StructDefinition DefinitionListR .)


state 10

    (37) FunctionDefinition -> FN ID . LPAREN ParameterListR RPAREN Block
    (38) FunctionDefinition -> FN ID . LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block

    LPAREN          shift and go to state 12
    LT              shift and go to state 13


state 11

    (68) StructDefinition -> STRUCT ID . LBRACE StructMemberListR RBRACE
    (69) StructDefinition -> STRUCT ID . LT TypeParameterListR GT LBRACE StructMemberListR RBRACE

    LBRACE          shift and go to state 14
    LT              shift and go to state 15


state 12

    (37) FunctionDefinition -> FN ID LPAREN . ParameterListR RPAREN Block
    (49) ParameterListR -> . Parameter COMMA ParameterListR
    (50) ParameterListR -> . Parameter
    (51) ParameterListR -> . empty
    (48) Parameter -> . Type ID
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RPAREN          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    ParameterListR                 shift and go to state 17
    Parameter                      shift and go to state 18
    empty                          shift and go to state 19
    Type                           shift and go to state 20

state 13

    (38) FunctionDefinition -> FN ID LT . TypeParameterListR GT LPAREN ParameterListR RPAREN Block
    (78) TypeParameterListR -> . ID COMMA TypeParameterListR
    (79) TypeParameterListR -> . ID
    (80) TypeParameterListR -> . empty
    (89) empty -> .

    ID              shift and go to state 21
    GT              reduce using rule 89 (empty -> .)

    TypeParameterListR             shift and go to state 22
    empty                          shift and go to state 23

state 14

    (68) StructDefinition -> STRUCT ID LBRACE . StructMemberListR RBRACE
    (71) StructMemberListR -> . StructMember StructMemberListR
    (72) StructMemberListR -> . empty
    (70) StructMember -> . Type ID SEMICOLON
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RBRACE          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    StructMemberListR              shift and go to state 24
    StructMember                   shift and go to state 25
    empty                          shift and go to state 26
    Type                           shift and go to state 27

state 15

    (69) StructDefinition -> STRUCT ID LT . TypeParameterListR GT LBRACE StructMemberListR RBRACE
    (78) TypeParameterListR -> . ID COMMA TypeParameterListR
    (79) TypeParameterListR -> . ID
    (80) TypeParameterListR -> . empty
    (89) empty -> .

    ID              shift and go to state 21
    GT              reduce using rule 89 (empty -> .)

    TypeParameterListR             shift and go to state 28
    empty                          shift and go to state 23

state 16

    (73) Type -> ID . PointerListR
    (74) Type -> ID . LT TypeArgumentListR GT PointerListR
    (52) PointerListR -> . TIMES PointerListR
    (53) PointerListR -> . empty
    (89) empty -> .

    LT              shift and go to state 30
    TIMES           shift and go to state 31
    ID              reduce using rule 89 (empty -> .)
    COMMA           reduce using rule 89 (empty -> .)
    GT              reduce using rule 89 (empty -> .)

    PointerListR                   shift and go to state 29
    empty                          shift and go to state 32

state 17

    (37) FunctionDefinition -> FN ID LPAREN ParameterListR . RPAREN Block

    RPAREN          shift and go to state 33


state 18

    (49) ParameterListR -> Parameter . COMMA ParameterListR
    (50) ParameterListR -> Parameter .

    COMMA           shift and go to state 34
    RPAREN          reduce using rule 50 (ParameterListR -> Parameter .)


state 19

    (51) ParameterListR -> empty .

    RPAREN          reduce using rule 51 (ParameterListR -> empty .)


state 20

    (48) Parameter -> Type . ID

    ID              shift and go to state 35


state 21

    (78) TypeParameterListR -> ID . COMMA TypeParameterListR
    (79) TypeParameterListR -> ID .

    COMMA           shift and go to state 36
    GT              reduce using rule 79 (TypeParameterListR -> ID .)


state 22

    (38) FunctionDefinition -> FN ID LT TypeParameterListR . GT LPAREN ParameterListR RPAREN Block

    GT              shift and go to state 37


state 23

    (80) TypeParameterListR -> empty .

    GT              reduce using rule 80 (TypeParameterListR -> empty .)


state 24

    (68) StructDefinition -> STRUCT ID LBRACE StructMemberListR . RBRACE

    RBRACE          shift and go to state 38


state 25

    (71) StructMemberListR -> StructMember . StructMemberListR
    (71) StructMemberListR -> . StructMember StructMemberListR
    (72) StructMemberListR -> . empty
    (70) StructMember -> . Type ID SEMICOLON
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RBRACE          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    StructMember                   shift and go to state 25
    StructMemberListR              shift and go to state 39
    empty                          shift and go to state 26
    Type                           shift and go to state 27

state 26

    (72) StructMemberListR -> empty .

    RBRACE          reduce using rule 72 (StructMemberListR -> empty .)


state 27

    (70) StructMember -> Type . ID SEMICOLON

    ID              shift and go to state 40


state 28

    (69) StructDefinition -> STRUCT ID LT TypeParameterListR . GT LBRACE StructMemberListR RBRACE

    GT              shift and go to state 41


state 29

    (73) Type -> ID PointerListR .

    ID              reduce using rule 73 (Type -> ID PointerListR .)
    COMMA           reduce using rule 73 (Type -> ID PointerListR .)
    GT              reduce using rule 73 (Type -> ID PointerListR .)


state 30

    (74) Type -> ID LT . TypeArgumentListR GT PointerListR
    (75) TypeArgumentListR -> . Type COMMA TypeArgumentListR
    (76) TypeArgumentListR -> . Type
    (77) TypeArgumentListR -> . empty
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR
    (89) empty -> .

    ID              shift and go to state 16
    GT              reduce using rule 89 (empty -> .)

    TypeArgumentListR              shift and go to state 42
    Type                           shift and go to state 43
    empty                          shift and go to state 44

state 31

    (52) PointerListR -> TIMES . PointerListR
    (52) PointerListR -> . TIMES PointerListR
    (53) PointerListR -> . empty
    (89) empty -> .

    TIMES           shift and go to state 31
    ID              reduce using rule 89 (empty -> .)
    COMMA           reduce using rule 89 (empty -> .)
    GT              reduce using rule 89 (empty -> .)

    PointerListR                   shift and go to state 45
    empty                          shift and go to state 32

state 32

    (53) PointerListR -> empty .

    ID              reduce using rule 53 (PointerListR -> empty .)
    COMMA           reduce using rule 53 (PointerListR -> empty .)
    GT              reduce using rule 53 (PointerListR -> empty .)


state 33

    (37) FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN . Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 46

state 34

    (49) ParameterListR -> Parameter COMMA . ParameterListR
    (49) ParameterListR -> . Parameter COMMA ParameterListR
    (50) ParameterListR -> . Parameter
    (51) ParameterListR -> . empty
    (48) Parameter -> . Type ID
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RPAREN          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    Parameter                      shift and go to state 18
    ParameterListR                 shift and go to state 48
    empty                          shift and go to state 19
    Type                           shift and go to state 20

state 35

    (48) Parameter -> Type ID .

    COMMA           reduce using rule 48 (Parameter -> Type ID .)
    RPAREN          reduce using rule 48 (Parameter -> Type ID .)


state 36

    (78) TypeParameterListR -> ID COMMA . TypeParameterListR
    (78) TypeParameterListR -> . ID COMMA TypeParameterListR
    (79) TypeParameterListR -> . ID
    (80) TypeParameterListR -> . empty
    (89) empty -> .

    ID              shift and go to state 21
    GT              reduce using rule 89 (empty -> .)

    TypeParameterListR             shift and go to state 49
    empty                          shift and go to state 23

state 37

    (38) FunctionDefinition -> FN ID LT TypeParameterListR GT . LPAREN ParameterListR RPAREN Block

    LPAREN          shift and go to state 50


state 38

    (68) StructDefinition -> STRUCT ID LBRACE StructMemberListR RBRACE .

    FN              reduce using rule 68 (StructDefinition -> STRUCT ID LBRACE StructMemberListR RBRACE .)
    STRUCT          reduce using rule 68 (StructDefinition -> STRUCT ID LBRACE StructMemberListR RBRACE .)
    $end            reduce using rule 68 (StructDefinition -> STRUCT ID LBRACE StructMemberListR RBRACE .)


state 39

    (71) StructMemberListR -> StructMember StructMemberListR .

    RBRACE          reduce using rule 71 (StructMemberListR -> StructMember StructMemberListR .)


state 40

    (70) StructMember -> Type ID . SEMICOLON

    SEMICOLON       shift and go to state 51


state 41

    (69) StructDefinition -> STRUCT ID LT TypeParameterListR GT . LBRACE StructMemberListR RBRACE

    LBRACE          shift and go to state 52


state 42

    (74) Type -> ID LT TypeArgumentListR . GT PointerListR

    GT              shift and go to state 53


state 43

    (75) TypeArgumentListR -> Type . COMMA TypeArgumentListR
    (76) TypeArgumentListR -> Type .

    COMMA           shift and go to state 54
    GT              reduce using rule 76 (TypeArgumentListR -> Type .)


state 44

    (77) TypeArgumentListR -> empty .

    GT              reduce using rule 77 (TypeArgumentListR -> empty .)


state 45

    (52) PointerListR -> TIMES PointerListR .

    ID              reduce using rule 52 (PointerListR -> TIMES PointerListR .)
    COMMA           reduce using rule 52 (PointerListR -> TIMES PointerListR .)
    GT              reduce using rule 52 (PointerListR -> TIMES PointerListR .)


state 46

    (37) FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN Block .

    FN              reduce using rule 37 (FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN Block .)
    STRUCT          reduce using rule 37 (FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN Block .)
    $end            reduce using rule 37 (FunctionDefinition -> FN ID LPAREN ParameterListR RPAREN Block .)


state 47

    (20) Block -> LBRACE . StatementListR RBRACE
    (66) StatementListR -> . Statement StatementListR
    (67) StatementListR -> . empty
    (56) Statement -> . AssignmentStatement
    (57) Statement -> . InitStatement
    (58) Statement -> . Expression SEMICOLON
    (59) Statement -> . IfElseStatement
    (60) Statement -> . ForStatement
    (61) Statement -> . WhileStatement
    (62) Statement -> . BreakStatement
    (63) Statement -> . ReturnStatement
    (64) Statement -> . BlockStatement
    (65) Statement -> . BlankStatement
    (89) empty -> .
    (6) AssignmentStatement -> . Expression ASSIGNMENT Expression SEMICOLON
    (7) AssignmentStatement -> . Expression ASSIGNMENT Expression
    (44) InitStatement -> . LET ID ASSIGNMENT InitCall SEMICOLON
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (41) IfElseStatement -> . IF LPAREN Expression RPAREN Block ELSE Block
    (34) ForStatement -> . FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block
    (88) WhileStatement -> . WHILE LPAREN Expression RPAREN Block
    (24) BreakStatement -> . BREAK INTL SEMICOLON
    (25) BreakStatement -> . BREAK SEMICOLON
    (54) ReturnStatement -> . RETURN Expression SEMICOLON
    (55) ReturnStatement -> . RETURN SEMICOLON
    (21) BlockStatement -> . Block
    (19) BlankStatement -> . ;
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (20) Block -> . LBRACE StatementListR RBRACE
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RBRACE          reduce using rule 89 (empty -> .)
    LET             shift and go to state 68
    IF              shift and go to state 74
    FOR             shift and go to state 77
    WHILE           shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 81
    ;               shift and go to state 82
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    LBRACE          shift and go to state 47
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    StatementListR                 shift and go to state 55
    Statement                      shift and go to state 56
    empty                          shift and go to state 57
    AssignmentStatement            shift and go to state 58
    InitStatement                  shift and go to state 59
    Expression                     shift and go to state 60
    IfElseStatement                shift and go to state 61
    ForStatement                   shift and go to state 62
    WhileStatement                 shift and go to state 63
    BreakStatement                 shift and go to state 64
    ReturnStatement                shift and go to state 65
    BlockStatement                 shift and go to state 66
    BlankStatement                 shift and go to state 67
    InitCall                       shift and go to state 70
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Block                          shift and go to state 76
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 48

    (49) ParameterListR -> Parameter COMMA ParameterListR .

    RPAREN          reduce using rule 49 (ParameterListR -> Parameter COMMA ParameterListR .)


state 49

    (78) TypeParameterListR -> ID COMMA TypeParameterListR .

    GT              reduce using rule 78 (TypeParameterListR -> ID COMMA TypeParameterListR .)


state 50

    (38) FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN . ParameterListR RPAREN Block
    (49) ParameterListR -> . Parameter COMMA ParameterListR
    (50) ParameterListR -> . Parameter
    (51) ParameterListR -> . empty
    (48) Parameter -> . Type ID
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RPAREN          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    ParameterListR                 shift and go to state 93
    Parameter                      shift and go to state 18
    empty                          shift and go to state 19
    Type                           shift and go to state 20

state 51

    (70) StructMember -> Type ID SEMICOLON .

    ID              reduce using rule 70 (StructMember -> Type ID SEMICOLON .)
    RBRACE          reduce using rule 70 (StructMember -> Type ID SEMICOLON .)


state 52

    (69) StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE . StructMemberListR RBRACE
    (71) StructMemberListR -> . StructMember StructMemberListR
    (72) StructMemberListR -> . empty
    (70) StructMember -> . Type ID SEMICOLON
    (89) empty -> .
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR

    RBRACE          reduce using rule 89 (empty -> .)
    ID              shift and go to state 16

    StructMemberListR              shift and go to state 94
    StructMember                   shift and go to state 25
    empty                          shift and go to state 26
    Type                           shift and go to state 27

state 53

    (74) Type -> ID LT TypeArgumentListR GT . PointerListR
    (52) PointerListR -> . TIMES PointerListR
    (53) PointerListR -> . empty
    (89) empty -> .

    TIMES           shift and go to state 31
    ID              reduce using rule 89 (empty -> .)
    COMMA           reduce using rule 89 (empty -> .)
    GT              reduce using rule 89 (empty -> .)

    PointerListR                   shift and go to state 95
    empty                          shift and go to state 32

state 54

    (75) TypeArgumentListR -> Type COMMA . TypeArgumentListR
    (75) TypeArgumentListR -> . Type COMMA TypeArgumentListR
    (76) TypeArgumentListR -> . Type
    (77) TypeArgumentListR -> . empty
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR
    (89) empty -> .

    ID              shift and go to state 16
    GT              reduce using rule 89 (empty -> .)

    Type                           shift and go to state 43
    TypeArgumentListR              shift and go to state 96
    empty                          shift and go to state 44

state 55

    (20) Block -> LBRACE StatementListR . RBRACE

    RBRACE          shift and go to state 97


state 56

    (66) StatementListR -> Statement . StatementListR
    (66) StatementListR -> . Statement StatementListR
    (67) StatementListR -> . empty
    (56) Statement -> . AssignmentStatement
    (57) Statement -> . InitStatement
    (58) Statement -> . Expression SEMICOLON
    (59) Statement -> . IfElseStatement
    (60) Statement -> . ForStatement
    (61) Statement -> . WhileStatement
    (62) Statement -> . BreakStatement
    (63) Statement -> . ReturnStatement
    (64) Statement -> . BlockStatement
    (65) Statement -> . BlankStatement
    (89) empty -> .
    (6) AssignmentStatement -> . Expression ASSIGNMENT Expression SEMICOLON
    (7) AssignmentStatement -> . Expression ASSIGNMENT Expression
    (44) InitStatement -> . LET ID ASSIGNMENT InitCall SEMICOLON
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (41) IfElseStatement -> . IF LPAREN Expression RPAREN Block ELSE Block
    (34) ForStatement -> . FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block
    (88) WhileStatement -> . WHILE LPAREN Expression RPAREN Block
    (24) BreakStatement -> . BREAK INTL SEMICOLON
    (25) BreakStatement -> . BREAK SEMICOLON
    (54) ReturnStatement -> . RETURN Expression SEMICOLON
    (55) ReturnStatement -> . RETURN SEMICOLON
    (21) BlockStatement -> . Block
    (19) BlankStatement -> . ;
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (20) Block -> . LBRACE StatementListR RBRACE
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RBRACE          reduce using rule 89 (empty -> .)
    LET             shift and go to state 68
    IF              shift and go to state 74
    FOR             shift and go to state 77
    WHILE           shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 81
    ;               shift and go to state 82
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    LBRACE          shift and go to state 47
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Statement                      shift and go to state 56
    StatementListR                 shift and go to state 98
    empty                          shift and go to state 57
    AssignmentStatement            shift and go to state 58
    InitStatement                  shift and go to state 59
    Expression                     shift and go to state 60
    IfElseStatement                shift and go to state 61
    ForStatement                   shift and go to state 62
    WhileStatement                 shift and go to state 63
    BreakStatement                 shift and go to state 64
    ReturnStatement                shift and go to state 65
    BlockStatement                 shift and go to state 66
    BlankStatement                 shift and go to state 67
    InitCall                       shift and go to state 70
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Block                          shift and go to state 76
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 57

    (67) StatementListR -> empty .

    RBRACE          reduce using rule 67 (StatementListR -> empty .)


state 58

    (56) Statement -> AssignmentStatement .

    LET             reduce using rule 56 (Statement -> AssignmentStatement .)
    IF              reduce using rule 56 (Statement -> AssignmentStatement .)
    FOR             reduce using rule 56 (Statement -> AssignmentStatement .)
    WHILE           reduce using rule 56 (Statement -> AssignmentStatement .)
    BREAK           reduce using rule 56 (Statement -> AssignmentStatement .)
    RETURN          reduce using rule 56 (Statement -> AssignmentStatement .)
    ;               reduce using rule 56 (Statement -> AssignmentStatement .)
    LPAREN          reduce using rule 56 (Statement -> AssignmentStatement .)
    ID              reduce using rule 56 (Statement -> AssignmentStatement .)
    LBRACE          reduce using rule 56 (Statement -> AssignmentStatement .)
    TIMES           reduce using rule 56 (Statement -> AssignmentStatement .)
    AMPERSAND       reduce using rule 56 (Statement -> AssignmentStatement .)
    INTL            reduce using rule 56 (Statement -> AssignmentStatement .)
    BOOLL           reduce using rule 56 (Statement -> AssignmentStatement .)
    RBRACE          reduce using rule 56 (Statement -> AssignmentStatement .)
    RPAREN          reduce using rule 56 (Statement -> AssignmentStatement .)


state 59

    (57) Statement -> InitStatement .

    LET             reduce using rule 57 (Statement -> InitStatement .)
    IF              reduce using rule 57 (Statement -> InitStatement .)
    FOR             reduce using rule 57 (Statement -> InitStatement .)
    WHILE           reduce using rule 57 (Statement -> InitStatement .)
    BREAK           reduce using rule 57 (Statement -> InitStatement .)
    RETURN          reduce using rule 57 (Statement -> InitStatement .)
    ;               reduce using rule 57 (Statement -> InitStatement .)
    LPAREN          reduce using rule 57 (Statement -> InitStatement .)
    ID              reduce using rule 57 (Statement -> InitStatement .)
    LBRACE          reduce using rule 57 (Statement -> InitStatement .)
    TIMES           reduce using rule 57 (Statement -> InitStatement .)
    AMPERSAND       reduce using rule 57 (Statement -> InitStatement .)
    INTL            reduce using rule 57 (Statement -> InitStatement .)
    BOOLL           reduce using rule 57 (Statement -> InitStatement .)
    RBRACE          reduce using rule 57 (Statement -> InitStatement .)
    RPAREN          reduce using rule 57 (Statement -> InitStatement .)


state 60

    (58) Statement -> Expression . SEMICOLON
    (6) AssignmentStatement -> Expression . ASSIGNMENT Expression SEMICOLON
    (7) AssignmentStatement -> Expression . ASSIGNMENT Expression
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       shift and go to state 99
    ASSIGNMENT      shift and go to state 100
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 61

    (59) Statement -> IfElseStatement .

    LET             reduce using rule 59 (Statement -> IfElseStatement .)
    IF              reduce using rule 59 (Statement -> IfElseStatement .)
    FOR             reduce using rule 59 (Statement -> IfElseStatement .)
    WHILE           reduce using rule 59 (Statement -> IfElseStatement .)
    BREAK           reduce using rule 59 (Statement -> IfElseStatement .)
    RETURN          reduce using rule 59 (Statement -> IfElseStatement .)
    ;               reduce using rule 59 (Statement -> IfElseStatement .)
    LPAREN          reduce using rule 59 (Statement -> IfElseStatement .)
    ID              reduce using rule 59 (Statement -> IfElseStatement .)
    LBRACE          reduce using rule 59 (Statement -> IfElseStatement .)
    TIMES           reduce using rule 59 (Statement -> IfElseStatement .)
    AMPERSAND       reduce using rule 59 (Statement -> IfElseStatement .)
    INTL            reduce using rule 59 (Statement -> IfElseStatement .)
    BOOLL           reduce using rule 59 (Statement -> IfElseStatement .)
    RBRACE          reduce using rule 59 (Statement -> IfElseStatement .)
    RPAREN          reduce using rule 59 (Statement -> IfElseStatement .)


state 62

    (60) Statement -> ForStatement .

    LET             reduce using rule 60 (Statement -> ForStatement .)
    IF              reduce using rule 60 (Statement -> ForStatement .)
    FOR             reduce using rule 60 (Statement -> ForStatement .)
    WHILE           reduce using rule 60 (Statement -> ForStatement .)
    BREAK           reduce using rule 60 (Statement -> ForStatement .)
    RETURN          reduce using rule 60 (Statement -> ForStatement .)
    ;               reduce using rule 60 (Statement -> ForStatement .)
    LPAREN          reduce using rule 60 (Statement -> ForStatement .)
    ID              reduce using rule 60 (Statement -> ForStatement .)
    LBRACE          reduce using rule 60 (Statement -> ForStatement .)
    TIMES           reduce using rule 60 (Statement -> ForStatement .)
    AMPERSAND       reduce using rule 60 (Statement -> ForStatement .)
    INTL            reduce using rule 60 (Statement -> ForStatement .)
    BOOLL           reduce using rule 60 (Statement -> ForStatement .)
    RBRACE          reduce using rule 60 (Statement -> ForStatement .)
    RPAREN          reduce using rule 60 (Statement -> ForStatement .)


state 63

    (61) Statement -> WhileStatement .

    LET             reduce using rule 61 (Statement -> WhileStatement .)
    IF              reduce using rule 61 (Statement -> WhileStatement .)
    FOR             reduce using rule 61 (Statement -> WhileStatement .)
    WHILE           reduce using rule 61 (Statement -> WhileStatement .)
    BREAK           reduce using rule 61 (Statement -> WhileStatement .)
    RETURN          reduce using rule 61 (Statement -> WhileStatement .)
    ;               reduce using rule 61 (Statement -> WhileStatement .)
    LPAREN          reduce using rule 61 (Statement -> WhileStatement .)
    ID              reduce using rule 61 (Statement -> WhileStatement .)
    LBRACE          reduce using rule 61 (Statement -> WhileStatement .)
    TIMES           reduce using rule 61 (Statement -> WhileStatement .)
    AMPERSAND       reduce using rule 61 (Statement -> WhileStatement .)
    INTL            reduce using rule 61 (Statement -> WhileStatement .)
    BOOLL           reduce using rule 61 (Statement -> WhileStatement .)
    RBRACE          reduce using rule 61 (Statement -> WhileStatement .)
    RPAREN          reduce using rule 61 (Statement -> WhileStatement .)


state 64

    (62) Statement -> BreakStatement .

    LET             reduce using rule 62 (Statement -> BreakStatement .)
    IF              reduce using rule 62 (Statement -> BreakStatement .)
    FOR             reduce using rule 62 (Statement -> BreakStatement .)
    WHILE           reduce using rule 62 (Statement -> BreakStatement .)
    BREAK           reduce using rule 62 (Statement -> BreakStatement .)
    RETURN          reduce using rule 62 (Statement -> BreakStatement .)
    ;               reduce using rule 62 (Statement -> BreakStatement .)
    LPAREN          reduce using rule 62 (Statement -> BreakStatement .)
    ID              reduce using rule 62 (Statement -> BreakStatement .)
    LBRACE          reduce using rule 62 (Statement -> BreakStatement .)
    TIMES           reduce using rule 62 (Statement -> BreakStatement .)
    AMPERSAND       reduce using rule 62 (Statement -> BreakStatement .)
    INTL            reduce using rule 62 (Statement -> BreakStatement .)
    BOOLL           reduce using rule 62 (Statement -> BreakStatement .)
    RBRACE          reduce using rule 62 (Statement -> BreakStatement .)
    RPAREN          reduce using rule 62 (Statement -> BreakStatement .)


state 65

    (63) Statement -> ReturnStatement .

    LET             reduce using rule 63 (Statement -> ReturnStatement .)
    IF              reduce using rule 63 (Statement -> ReturnStatement .)
    FOR             reduce using rule 63 (Statement -> ReturnStatement .)
    WHILE           reduce using rule 63 (Statement -> ReturnStatement .)
    BREAK           reduce using rule 63 (Statement -> ReturnStatement .)
    RETURN          reduce using rule 63 (Statement -> ReturnStatement .)
    ;               reduce using rule 63 (Statement -> ReturnStatement .)
    LPAREN          reduce using rule 63 (Statement -> ReturnStatement .)
    ID              reduce using rule 63 (Statement -> ReturnStatement .)
    LBRACE          reduce using rule 63 (Statement -> ReturnStatement .)
    TIMES           reduce using rule 63 (Statement -> ReturnStatement .)
    AMPERSAND       reduce using rule 63 (Statement -> ReturnStatement .)
    INTL            reduce using rule 63 (Statement -> ReturnStatement .)
    BOOLL           reduce using rule 63 (Statement -> ReturnStatement .)
    RBRACE          reduce using rule 63 (Statement -> ReturnStatement .)
    RPAREN          reduce using rule 63 (Statement -> ReturnStatement .)


state 66

    (64) Statement -> BlockStatement .

    LET             reduce using rule 64 (Statement -> BlockStatement .)
    IF              reduce using rule 64 (Statement -> BlockStatement .)
    FOR             reduce using rule 64 (Statement -> BlockStatement .)
    WHILE           reduce using rule 64 (Statement -> BlockStatement .)
    BREAK           reduce using rule 64 (Statement -> BlockStatement .)
    RETURN          reduce using rule 64 (Statement -> BlockStatement .)
    ;               reduce using rule 64 (Statement -> BlockStatement .)
    LPAREN          reduce using rule 64 (Statement -> BlockStatement .)
    ID              reduce using rule 64 (Statement -> BlockStatement .)
    LBRACE          reduce using rule 64 (Statement -> BlockStatement .)
    TIMES           reduce using rule 64 (Statement -> BlockStatement .)
    AMPERSAND       reduce using rule 64 (Statement -> BlockStatement .)
    INTL            reduce using rule 64 (Statement -> BlockStatement .)
    BOOLL           reduce using rule 64 (Statement -> BlockStatement .)
    RBRACE          reduce using rule 64 (Statement -> BlockStatement .)
    RPAREN          reduce using rule 64 (Statement -> BlockStatement .)


state 67

    (65) Statement -> BlankStatement .

    LET             reduce using rule 65 (Statement -> BlankStatement .)
    IF              reduce using rule 65 (Statement -> BlankStatement .)
    FOR             reduce using rule 65 (Statement -> BlankStatement .)
    WHILE           reduce using rule 65 (Statement -> BlankStatement .)
    BREAK           reduce using rule 65 (Statement -> BlankStatement .)
    RETURN          reduce using rule 65 (Statement -> BlankStatement .)
    ;               reduce using rule 65 (Statement -> BlankStatement .)
    LPAREN          reduce using rule 65 (Statement -> BlankStatement .)
    ID              reduce using rule 65 (Statement -> BlankStatement .)
    LBRACE          reduce using rule 65 (Statement -> BlankStatement .)
    TIMES           reduce using rule 65 (Statement -> BlankStatement .)
    AMPERSAND       reduce using rule 65 (Statement -> BlankStatement .)
    INTL            reduce using rule 65 (Statement -> BlankStatement .)
    BOOLL           reduce using rule 65 (Statement -> BlankStatement .)
    RBRACE          reduce using rule 65 (Statement -> BlankStatement .)
    RPAREN          reduce using rule 65 (Statement -> BlankStatement .)


state 68

    (44) InitStatement -> LET . ID ASSIGNMENT InitCall SEMICOLON

    ID              shift and go to state 113


state 69

    (39) IdExpression -> ID .
    (35) FunctionCall -> ID . LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> ID . LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (42) InitCall -> ID . LBRACE ArgumentListR RBRACE
    (43) InitCall -> ID . LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    DOT             reduce using rule 39 (IdExpression -> ID .)
    SEMICOLON       reduce using rule 39 (IdExpression -> ID .)
    ASSIGNMENT      reduce using rule 39 (IdExpression -> ID .)
    PLUS            reduce using rule 39 (IdExpression -> ID .)
    MINUS           reduce using rule 39 (IdExpression -> ID .)
    TIMES           reduce using rule 39 (IdExpression -> ID .)
    DIVIDE          reduce using rule 39 (IdExpression -> ID .)
    MOD             reduce using rule 39 (IdExpression -> ID .)
    LEQ             reduce using rule 39 (IdExpression -> ID .)
    GEQ             reduce using rule 39 (IdExpression -> ID .)
    GT              reduce using rule 39 (IdExpression -> ID .)
    EQ              reduce using rule 39 (IdExpression -> ID .)
    NE              reduce using rule 39 (IdExpression -> ID .)
    LBRACKET        reduce using rule 39 (IdExpression -> ID .)
    RPAREN          reduce using rule 39 (IdExpression -> ID .)
    LET             reduce using rule 39 (IdExpression -> ID .)
    IF              reduce using rule 39 (IdExpression -> ID .)
    FOR             reduce using rule 39 (IdExpression -> ID .)
    WHILE           reduce using rule 39 (IdExpression -> ID .)
    BREAK           reduce using rule 39 (IdExpression -> ID .)
    RETURN          reduce using rule 39 (IdExpression -> ID .)
    ;               reduce using rule 39 (IdExpression -> ID .)
    ID              reduce using rule 39 (IdExpression -> ID .)
    AMPERSAND       reduce using rule 39 (IdExpression -> ID .)
    INTL            reduce using rule 39 (IdExpression -> ID .)
    BOOLL           reduce using rule 39 (IdExpression -> ID .)
    RBRACE          reduce using rule 39 (IdExpression -> ID .)
    RBRACKET        reduce using rule 39 (IdExpression -> ID .)
    COMMA           reduce using rule 39 (IdExpression -> ID .)
    LPAREN          shift and go to state 114
    LT              shift and go to state 115
    LBRACE          shift and go to state 116

  ! LT              [ reduce using rule 39 (IdExpression -> ID .) ]
  ! LPAREN          [ reduce using rule 39 (IdExpression -> ID .) ]
  ! LBRACE          [ reduce using rule 39 (IdExpression -> ID .) ]


state 70

    (84) UnaryExpression -> InitCall .

    SEMICOLON       reduce using rule 84 (UnaryExpression -> InitCall .)
    ASSIGNMENT      reduce using rule 84 (UnaryExpression -> InitCall .)
    PLUS            reduce using rule 84 (UnaryExpression -> InitCall .)
    MINUS           reduce using rule 84 (UnaryExpression -> InitCall .)
    TIMES           reduce using rule 84 (UnaryExpression -> InitCall .)
    DIVIDE          reduce using rule 84 (UnaryExpression -> InitCall .)
    MOD             reduce using rule 84 (UnaryExpression -> InitCall .)
    LEQ             reduce using rule 84 (UnaryExpression -> InitCall .)
    GEQ             reduce using rule 84 (UnaryExpression -> InitCall .)
    LT              reduce using rule 84 (UnaryExpression -> InitCall .)
    GT              reduce using rule 84 (UnaryExpression -> InitCall .)
    EQ              reduce using rule 84 (UnaryExpression -> InitCall .)
    NE              reduce using rule 84 (UnaryExpression -> InitCall .)
    LBRACKET        reduce using rule 84 (UnaryExpression -> InitCall .)
    RPAREN          reduce using rule 84 (UnaryExpression -> InitCall .)
    LET             reduce using rule 84 (UnaryExpression -> InitCall .)
    IF              reduce using rule 84 (UnaryExpression -> InitCall .)
    FOR             reduce using rule 84 (UnaryExpression -> InitCall .)
    WHILE           reduce using rule 84 (UnaryExpression -> InitCall .)
    BREAK           reduce using rule 84 (UnaryExpression -> InitCall .)
    RETURN          reduce using rule 84 (UnaryExpression -> InitCall .)
    ;               reduce using rule 84 (UnaryExpression -> InitCall .)
    LPAREN          reduce using rule 84 (UnaryExpression -> InitCall .)
    ID              reduce using rule 84 (UnaryExpression -> InitCall .)
    LBRACE          reduce using rule 84 (UnaryExpression -> InitCall .)
    AMPERSAND       reduce using rule 84 (UnaryExpression -> InitCall .)
    INTL            reduce using rule 84 (UnaryExpression -> InitCall .)
    BOOLL           reduce using rule 84 (UnaryExpression -> InitCall .)
    RBRACE          reduce using rule 84 (UnaryExpression -> InitCall .)
    RBRACKET        reduce using rule 84 (UnaryExpression -> InitCall .)
    COMMA           reduce using rule 84 (UnaryExpression -> InitCall .)


state 71

    (31) Expression -> BinaryExpression .

    SEMICOLON       reduce using rule 31 (Expression -> BinaryExpression .)
    ASSIGNMENT      reduce using rule 31 (Expression -> BinaryExpression .)
    PLUS            reduce using rule 31 (Expression -> BinaryExpression .)
    MINUS           reduce using rule 31 (Expression -> BinaryExpression .)
    TIMES           reduce using rule 31 (Expression -> BinaryExpression .)
    DIVIDE          reduce using rule 31 (Expression -> BinaryExpression .)
    MOD             reduce using rule 31 (Expression -> BinaryExpression .)
    LEQ             reduce using rule 31 (Expression -> BinaryExpression .)
    GEQ             reduce using rule 31 (Expression -> BinaryExpression .)
    LT              reduce using rule 31 (Expression -> BinaryExpression .)
    GT              reduce using rule 31 (Expression -> BinaryExpression .)
    EQ              reduce using rule 31 (Expression -> BinaryExpression .)
    NE              reduce using rule 31 (Expression -> BinaryExpression .)
    LBRACKET        reduce using rule 31 (Expression -> BinaryExpression .)
    RPAREN          reduce using rule 31 (Expression -> BinaryExpression .)
    LET             reduce using rule 31 (Expression -> BinaryExpression .)
    IF              reduce using rule 31 (Expression -> BinaryExpression .)
    FOR             reduce using rule 31 (Expression -> BinaryExpression .)
    WHILE           reduce using rule 31 (Expression -> BinaryExpression .)
    BREAK           reduce using rule 31 (Expression -> BinaryExpression .)
    RETURN          reduce using rule 31 (Expression -> BinaryExpression .)
    ;               reduce using rule 31 (Expression -> BinaryExpression .)
    LPAREN          reduce using rule 31 (Expression -> BinaryExpression .)
    ID              reduce using rule 31 (Expression -> BinaryExpression .)
    LBRACE          reduce using rule 31 (Expression -> BinaryExpression .)
    AMPERSAND       reduce using rule 31 (Expression -> BinaryExpression .)
    INTL            reduce using rule 31 (Expression -> BinaryExpression .)
    BOOLL           reduce using rule 31 (Expression -> BinaryExpression .)
    RBRACE          reduce using rule 31 (Expression -> BinaryExpression .)
    RBRACKET        reduce using rule 31 (Expression -> BinaryExpression .)
    COMMA           reduce using rule 31 (Expression -> BinaryExpression .)


state 72

    (32) Expression -> UnaryExpression .

    SEMICOLON       reduce using rule 32 (Expression -> UnaryExpression .)
    ASSIGNMENT      reduce using rule 32 (Expression -> UnaryExpression .)
    PLUS            reduce using rule 32 (Expression -> UnaryExpression .)
    MINUS           reduce using rule 32 (Expression -> UnaryExpression .)
    TIMES           reduce using rule 32 (Expression -> UnaryExpression .)
    DIVIDE          reduce using rule 32 (Expression -> UnaryExpression .)
    MOD             reduce using rule 32 (Expression -> UnaryExpression .)
    LEQ             reduce using rule 32 (Expression -> UnaryExpression .)
    GEQ             reduce using rule 32 (Expression -> UnaryExpression .)
    LT              reduce using rule 32 (Expression -> UnaryExpression .)
    GT              reduce using rule 32 (Expression -> UnaryExpression .)
    EQ              reduce using rule 32 (Expression -> UnaryExpression .)
    NE              reduce using rule 32 (Expression -> UnaryExpression .)
    LBRACKET        reduce using rule 32 (Expression -> UnaryExpression .)
    RPAREN          reduce using rule 32 (Expression -> UnaryExpression .)
    LET             reduce using rule 32 (Expression -> UnaryExpression .)
    IF              reduce using rule 32 (Expression -> UnaryExpression .)
    FOR             reduce using rule 32 (Expression -> UnaryExpression .)
    WHILE           reduce using rule 32 (Expression -> UnaryExpression .)
    BREAK           reduce using rule 32 (Expression -> UnaryExpression .)
    RETURN          reduce using rule 32 (Expression -> UnaryExpression .)
    ;               reduce using rule 32 (Expression -> UnaryExpression .)
    LPAREN          reduce using rule 32 (Expression -> UnaryExpression .)
    ID              reduce using rule 32 (Expression -> UnaryExpression .)
    LBRACE          reduce using rule 32 (Expression -> UnaryExpression .)
    AMPERSAND       reduce using rule 32 (Expression -> UnaryExpression .)
    INTL            reduce using rule 32 (Expression -> UnaryExpression .)
    BOOLL           reduce using rule 32 (Expression -> UnaryExpression .)
    RBRACE          reduce using rule 32 (Expression -> UnaryExpression .)
    RBRACKET        reduce using rule 32 (Expression -> UnaryExpression .)
    COMMA           reduce using rule 32 (Expression -> UnaryExpression .)


state 73

    (33) Expression -> IdExpression .
    (40) IdExpression -> IdExpression . DOT ID

    SEMICOLON       reduce using rule 33 (Expression -> IdExpression .)
    ASSIGNMENT      reduce using rule 33 (Expression -> IdExpression .)
    PLUS            reduce using rule 33 (Expression -> IdExpression .)
    MINUS           reduce using rule 33 (Expression -> IdExpression .)
    TIMES           reduce using rule 33 (Expression -> IdExpression .)
    DIVIDE          reduce using rule 33 (Expression -> IdExpression .)
    MOD             reduce using rule 33 (Expression -> IdExpression .)
    LEQ             reduce using rule 33 (Expression -> IdExpression .)
    GEQ             reduce using rule 33 (Expression -> IdExpression .)
    LT              reduce using rule 33 (Expression -> IdExpression .)
    GT              reduce using rule 33 (Expression -> IdExpression .)
    EQ              reduce using rule 33 (Expression -> IdExpression .)
    NE              reduce using rule 33 (Expression -> IdExpression .)
    LBRACKET        reduce using rule 33 (Expression -> IdExpression .)
    RPAREN          reduce using rule 33 (Expression -> IdExpression .)
    LET             reduce using rule 33 (Expression -> IdExpression .)
    IF              reduce using rule 33 (Expression -> IdExpression .)
    FOR             reduce using rule 33 (Expression -> IdExpression .)
    WHILE           reduce using rule 33 (Expression -> IdExpression .)
    BREAK           reduce using rule 33 (Expression -> IdExpression .)
    RETURN          reduce using rule 33 (Expression -> IdExpression .)
    ;               reduce using rule 33 (Expression -> IdExpression .)
    LPAREN          reduce using rule 33 (Expression -> IdExpression .)
    ID              reduce using rule 33 (Expression -> IdExpression .)
    LBRACE          reduce using rule 33 (Expression -> IdExpression .)
    AMPERSAND       reduce using rule 33 (Expression -> IdExpression .)
    INTL            reduce using rule 33 (Expression -> IdExpression .)
    BOOLL           reduce using rule 33 (Expression -> IdExpression .)
    RBRACE          reduce using rule 33 (Expression -> IdExpression .)
    RBRACKET        reduce using rule 33 (Expression -> IdExpression .)
    COMMA           reduce using rule 33 (Expression -> IdExpression .)
    DOT             shift and go to state 117


state 74

    (41) IfElseStatement -> IF . LPAREN Expression RPAREN Block ELSE Block

    LPAREN          shift and go to state 118


state 75

    (85) UnaryExpression -> LPAREN . Expression RPAREN
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 119
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 76

    (21) BlockStatement -> Block .

    LET             reduce using rule 21 (BlockStatement -> Block .)
    IF              reduce using rule 21 (BlockStatement -> Block .)
    FOR             reduce using rule 21 (BlockStatement -> Block .)
    WHILE           reduce using rule 21 (BlockStatement -> Block .)
    BREAK           reduce using rule 21 (BlockStatement -> Block .)
    RETURN          reduce using rule 21 (BlockStatement -> Block .)
    ;               reduce using rule 21 (BlockStatement -> Block .)
    LPAREN          reduce using rule 21 (BlockStatement -> Block .)
    ID              reduce using rule 21 (BlockStatement -> Block .)
    LBRACE          reduce using rule 21 (BlockStatement -> Block .)
    TIMES           reduce using rule 21 (BlockStatement -> Block .)
    AMPERSAND       reduce using rule 21 (BlockStatement -> Block .)
    INTL            reduce using rule 21 (BlockStatement -> Block .)
    BOOLL           reduce using rule 21 (BlockStatement -> Block .)
    RBRACE          reduce using rule 21 (BlockStatement -> Block .)
    RPAREN          reduce using rule 21 (BlockStatement -> Block .)


state 77

    (34) ForStatement -> FOR . LPAREN Statement Expression SEMICOLON Statement RPAREN Block

    LPAREN          shift and go to state 120


state 78

    (88) WhileStatement -> WHILE . LPAREN Expression RPAREN Block

    LPAREN          shift and go to state 121


state 79

    (24) BreakStatement -> BREAK . INTL SEMICOLON
    (25) BreakStatement -> BREAK . SEMICOLON

    INTL            shift and go to state 122
    SEMICOLON       shift and go to state 123


state 80

    (45) IntLiteral -> INTL .

    SEMICOLON       reduce using rule 45 (IntLiteral -> INTL .)
    ASSIGNMENT      reduce using rule 45 (IntLiteral -> INTL .)
    PLUS            reduce using rule 45 (IntLiteral -> INTL .)
    MINUS           reduce using rule 45 (IntLiteral -> INTL .)
    TIMES           reduce using rule 45 (IntLiteral -> INTL .)
    DIVIDE          reduce using rule 45 (IntLiteral -> INTL .)
    MOD             reduce using rule 45 (IntLiteral -> INTL .)
    LEQ             reduce using rule 45 (IntLiteral -> INTL .)
    GEQ             reduce using rule 45 (IntLiteral -> INTL .)
    LT              reduce using rule 45 (IntLiteral -> INTL .)
    GT              reduce using rule 45 (IntLiteral -> INTL .)
    EQ              reduce using rule 45 (IntLiteral -> INTL .)
    NE              reduce using rule 45 (IntLiteral -> INTL .)
    LBRACKET        reduce using rule 45 (IntLiteral -> INTL .)
    RPAREN          reduce using rule 45 (IntLiteral -> INTL .)
    LET             reduce using rule 45 (IntLiteral -> INTL .)
    IF              reduce using rule 45 (IntLiteral -> INTL .)
    FOR             reduce using rule 45 (IntLiteral -> INTL .)
    WHILE           reduce using rule 45 (IntLiteral -> INTL .)
    BREAK           reduce using rule 45 (IntLiteral -> INTL .)
    RETURN          reduce using rule 45 (IntLiteral -> INTL .)
    ;               reduce using rule 45 (IntLiteral -> INTL .)
    LPAREN          reduce using rule 45 (IntLiteral -> INTL .)
    ID              reduce using rule 45 (IntLiteral -> INTL .)
    LBRACE          reduce using rule 45 (IntLiteral -> INTL .)
    AMPERSAND       reduce using rule 45 (IntLiteral -> INTL .)
    INTL            reduce using rule 45 (IntLiteral -> INTL .)
    BOOLL           reduce using rule 45 (IntLiteral -> INTL .)
    RBRACE          reduce using rule 45 (IntLiteral -> INTL .)
    RBRACKET        reduce using rule 45 (IntLiteral -> INTL .)
    COMMA           reduce using rule 45 (IntLiteral -> INTL .)


state 81

    (54) ReturnStatement -> RETURN . Expression SEMICOLON
    (55) ReturnStatement -> RETURN . SEMICOLON
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    SEMICOLON       shift and go to state 125
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 124
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 82

    (19) BlankStatement -> ; .

    LET             reduce using rule 19 (BlankStatement -> ; .)
    IF              reduce using rule 19 (BlankStatement -> ; .)
    FOR             reduce using rule 19 (BlankStatement -> ; .)
    WHILE           reduce using rule 19 (BlankStatement -> ; .)
    BREAK           reduce using rule 19 (BlankStatement -> ; .)
    RETURN          reduce using rule 19 (BlankStatement -> ; .)
    ;               reduce using rule 19 (BlankStatement -> ; .)
    LPAREN          reduce using rule 19 (BlankStatement -> ; .)
    ID              reduce using rule 19 (BlankStatement -> ; .)
    LBRACE          reduce using rule 19 (BlankStatement -> ; .)
    TIMES           reduce using rule 19 (BlankStatement -> ; .)
    AMPERSAND       reduce using rule 19 (BlankStatement -> ; .)
    INTL            reduce using rule 19 (BlankStatement -> ; .)
    BOOLL           reduce using rule 19 (BlankStatement -> ; .)
    RBRACE          reduce using rule 19 (BlankStatement -> ; .)
    RPAREN          reduce using rule 19 (BlankStatement -> ; .)


state 83

    (30) DereferenceExpression -> TIMES . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 126
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 84

    (81) UnaryExpression -> Literal .

    SEMICOLON       reduce using rule 81 (UnaryExpression -> Literal .)
    ASSIGNMENT      reduce using rule 81 (UnaryExpression -> Literal .)
    PLUS            reduce using rule 81 (UnaryExpression -> Literal .)
    MINUS           reduce using rule 81 (UnaryExpression -> Literal .)
    TIMES           reduce using rule 81 (UnaryExpression -> Literal .)
    DIVIDE          reduce using rule 81 (UnaryExpression -> Literal .)
    MOD             reduce using rule 81 (UnaryExpression -> Literal .)
    LEQ             reduce using rule 81 (UnaryExpression -> Literal .)
    GEQ             reduce using rule 81 (UnaryExpression -> Literal .)
    LT              reduce using rule 81 (UnaryExpression -> Literal .)
    GT              reduce using rule 81 (UnaryExpression -> Literal .)
    EQ              reduce using rule 81 (UnaryExpression -> Literal .)
    NE              reduce using rule 81 (UnaryExpression -> Literal .)
    LBRACKET        reduce using rule 81 (UnaryExpression -> Literal .)
    RPAREN          reduce using rule 81 (UnaryExpression -> Literal .)
    LET             reduce using rule 81 (UnaryExpression -> Literal .)
    IF              reduce using rule 81 (UnaryExpression -> Literal .)
    FOR             reduce using rule 81 (UnaryExpression -> Literal .)
    WHILE           reduce using rule 81 (UnaryExpression -> Literal .)
    BREAK           reduce using rule 81 (UnaryExpression -> Literal .)
    RETURN          reduce using rule 81 (UnaryExpression -> Literal .)
    ;               reduce using rule 81 (UnaryExpression -> Literal .)
    LPAREN          reduce using rule 81 (UnaryExpression -> Literal .)
    ID              reduce using rule 81 (UnaryExpression -> Literal .)
    LBRACE          reduce using rule 81 (UnaryExpression -> Literal .)
    AMPERSAND       reduce using rule 81 (UnaryExpression -> Literal .)
    INTL            reduce using rule 81 (UnaryExpression -> Literal .)
    BOOLL           reduce using rule 81 (UnaryExpression -> Literal .)
    RBRACE          reduce using rule 81 (UnaryExpression -> Literal .)
    RBRACKET        reduce using rule 81 (UnaryExpression -> Literal .)
    COMMA           reduce using rule 81 (UnaryExpression -> Literal .)


state 85

    (82) UnaryExpression -> FunctionCall .

    SEMICOLON       reduce using rule 82 (UnaryExpression -> FunctionCall .)
    ASSIGNMENT      reduce using rule 82 (UnaryExpression -> FunctionCall .)
    PLUS            reduce using rule 82 (UnaryExpression -> FunctionCall .)
    MINUS           reduce using rule 82 (UnaryExpression -> FunctionCall .)
    TIMES           reduce using rule 82 (UnaryExpression -> FunctionCall .)
    DIVIDE          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    MOD             reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LEQ             reduce using rule 82 (UnaryExpression -> FunctionCall .)
    GEQ             reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LT              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    GT              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    EQ              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    NE              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LBRACKET        reduce using rule 82 (UnaryExpression -> FunctionCall .)
    RPAREN          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LET             reduce using rule 82 (UnaryExpression -> FunctionCall .)
    IF              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    FOR             reduce using rule 82 (UnaryExpression -> FunctionCall .)
    WHILE           reduce using rule 82 (UnaryExpression -> FunctionCall .)
    BREAK           reduce using rule 82 (UnaryExpression -> FunctionCall .)
    RETURN          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    ;               reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LPAREN          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    ID              reduce using rule 82 (UnaryExpression -> FunctionCall .)
    LBRACE          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    AMPERSAND       reduce using rule 82 (UnaryExpression -> FunctionCall .)
    INTL            reduce using rule 82 (UnaryExpression -> FunctionCall .)
    BOOLL           reduce using rule 82 (UnaryExpression -> FunctionCall .)
    RBRACE          reduce using rule 82 (UnaryExpression -> FunctionCall .)
    RBRACKET        reduce using rule 82 (UnaryExpression -> FunctionCall .)
    COMMA           reduce using rule 82 (UnaryExpression -> FunctionCall .)


state 86

    (83) UnaryExpression -> BracketCall .

    SEMICOLON       reduce using rule 83 (UnaryExpression -> BracketCall .)
    ASSIGNMENT      reduce using rule 83 (UnaryExpression -> BracketCall .)
    PLUS            reduce using rule 83 (UnaryExpression -> BracketCall .)
    MINUS           reduce using rule 83 (UnaryExpression -> BracketCall .)
    TIMES           reduce using rule 83 (UnaryExpression -> BracketCall .)
    DIVIDE          reduce using rule 83 (UnaryExpression -> BracketCall .)
    MOD             reduce using rule 83 (UnaryExpression -> BracketCall .)
    LEQ             reduce using rule 83 (UnaryExpression -> BracketCall .)
    GEQ             reduce using rule 83 (UnaryExpression -> BracketCall .)
    LT              reduce using rule 83 (UnaryExpression -> BracketCall .)
    GT              reduce using rule 83 (UnaryExpression -> BracketCall .)
    EQ              reduce using rule 83 (UnaryExpression -> BracketCall .)
    NE              reduce using rule 83 (UnaryExpression -> BracketCall .)
    LBRACKET        reduce using rule 83 (UnaryExpression -> BracketCall .)
    RPAREN          reduce using rule 83 (UnaryExpression -> BracketCall .)
    LET             reduce using rule 83 (UnaryExpression -> BracketCall .)
    IF              reduce using rule 83 (UnaryExpression -> BracketCall .)
    FOR             reduce using rule 83 (UnaryExpression -> BracketCall .)
    WHILE           reduce using rule 83 (UnaryExpression -> BracketCall .)
    BREAK           reduce using rule 83 (UnaryExpression -> BracketCall .)
    RETURN          reduce using rule 83 (UnaryExpression -> BracketCall .)
    ;               reduce using rule 83 (UnaryExpression -> BracketCall .)
    LPAREN          reduce using rule 83 (UnaryExpression -> BracketCall .)
    ID              reduce using rule 83 (UnaryExpression -> BracketCall .)
    LBRACE          reduce using rule 83 (UnaryExpression -> BracketCall .)
    AMPERSAND       reduce using rule 83 (UnaryExpression -> BracketCall .)
    INTL            reduce using rule 83 (UnaryExpression -> BracketCall .)
    BOOLL           reduce using rule 83 (UnaryExpression -> BracketCall .)
    RBRACE          reduce using rule 83 (UnaryExpression -> BracketCall .)
    RBRACKET        reduce using rule 83 (UnaryExpression -> BracketCall .)
    COMMA           reduce using rule 83 (UnaryExpression -> BracketCall .)


state 87

    (86) UnaryExpression -> DereferenceExpression .

    SEMICOLON       reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    ASSIGNMENT      reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    PLUS            reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    MINUS           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    TIMES           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    DIVIDE          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    MOD             reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LEQ             reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    GEQ             reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LT              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    GT              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    EQ              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    NE              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LBRACKET        reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    RPAREN          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LET             reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    IF              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    FOR             reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    WHILE           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    BREAK           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    RETURN          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    ;               reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LPAREN          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    ID              reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    LBRACE          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    AMPERSAND       reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    INTL            reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    BOOLL           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    RBRACE          reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    RBRACKET        reduce using rule 86 (UnaryExpression -> DereferenceExpression .)
    COMMA           reduce using rule 86 (UnaryExpression -> DereferenceExpression .)


state 88

    (87) UnaryExpression -> AddressExpression .

    SEMICOLON       reduce using rule 87 (UnaryExpression -> AddressExpression .)
    ASSIGNMENT      reduce using rule 87 (UnaryExpression -> AddressExpression .)
    PLUS            reduce using rule 87 (UnaryExpression -> AddressExpression .)
    MINUS           reduce using rule 87 (UnaryExpression -> AddressExpression .)
    TIMES           reduce using rule 87 (UnaryExpression -> AddressExpression .)
    DIVIDE          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    MOD             reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LEQ             reduce using rule 87 (UnaryExpression -> AddressExpression .)
    GEQ             reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LT              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    GT              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    EQ              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    NE              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LBRACKET        reduce using rule 87 (UnaryExpression -> AddressExpression .)
    RPAREN          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LET             reduce using rule 87 (UnaryExpression -> AddressExpression .)
    IF              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    FOR             reduce using rule 87 (UnaryExpression -> AddressExpression .)
    WHILE           reduce using rule 87 (UnaryExpression -> AddressExpression .)
    BREAK           reduce using rule 87 (UnaryExpression -> AddressExpression .)
    RETURN          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    ;               reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LPAREN          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    ID              reduce using rule 87 (UnaryExpression -> AddressExpression .)
    LBRACE          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    AMPERSAND       reduce using rule 87 (UnaryExpression -> AddressExpression .)
    INTL            reduce using rule 87 (UnaryExpression -> AddressExpression .)
    BOOLL           reduce using rule 87 (UnaryExpression -> AddressExpression .)
    RBRACE          reduce using rule 87 (UnaryExpression -> AddressExpression .)
    RBRACKET        reduce using rule 87 (UnaryExpression -> AddressExpression .)
    COMMA           reduce using rule 87 (UnaryExpression -> AddressExpression .)


state 89

    (46) Literal -> IntLiteral .

    SEMICOLON       reduce using rule 46 (Literal -> IntLiteral .)
    ASSIGNMENT      reduce using rule 46 (Literal -> IntLiteral .)
    PLUS            reduce using rule 46 (Literal -> IntLiteral .)
    MINUS           reduce using rule 46 (Literal -> IntLiteral .)
    TIMES           reduce using rule 46 (Literal -> IntLiteral .)
    DIVIDE          reduce using rule 46 (Literal -> IntLiteral .)
    MOD             reduce using rule 46 (Literal -> IntLiteral .)
    LEQ             reduce using rule 46 (Literal -> IntLiteral .)
    GEQ             reduce using rule 46 (Literal -> IntLiteral .)
    LT              reduce using rule 46 (Literal -> IntLiteral .)
    GT              reduce using rule 46 (Literal -> IntLiteral .)
    EQ              reduce using rule 46 (Literal -> IntLiteral .)
    NE              reduce using rule 46 (Literal -> IntLiteral .)
    LBRACKET        reduce using rule 46 (Literal -> IntLiteral .)
    RPAREN          reduce using rule 46 (Literal -> IntLiteral .)
    LET             reduce using rule 46 (Literal -> IntLiteral .)
    IF              reduce using rule 46 (Literal -> IntLiteral .)
    FOR             reduce using rule 46 (Literal -> IntLiteral .)
    WHILE           reduce using rule 46 (Literal -> IntLiteral .)
    BREAK           reduce using rule 46 (Literal -> IntLiteral .)
    RETURN          reduce using rule 46 (Literal -> IntLiteral .)
    ;               reduce using rule 46 (Literal -> IntLiteral .)
    LPAREN          reduce using rule 46 (Literal -> IntLiteral .)
    ID              reduce using rule 46 (Literal -> IntLiteral .)
    LBRACE          reduce using rule 46 (Literal -> IntLiteral .)
    AMPERSAND       reduce using rule 46 (Literal -> IntLiteral .)
    INTL            reduce using rule 46 (Literal -> IntLiteral .)
    BOOLL           reduce using rule 46 (Literal -> IntLiteral .)
    RBRACE          reduce using rule 46 (Literal -> IntLiteral .)
    RBRACKET        reduce using rule 46 (Literal -> IntLiteral .)
    COMMA           reduce using rule 46 (Literal -> IntLiteral .)


state 90

    (47) Literal -> BoolLiteral .

    SEMICOLON       reduce using rule 47 (Literal -> BoolLiteral .)
    ASSIGNMENT      reduce using rule 47 (Literal -> BoolLiteral .)
    PLUS            reduce using rule 47 (Literal -> BoolLiteral .)
    MINUS           reduce using rule 47 (Literal -> BoolLiteral .)
    TIMES           reduce using rule 47 (Literal -> BoolLiteral .)
    DIVIDE          reduce using rule 47 (Literal -> BoolLiteral .)
    MOD             reduce using rule 47 (Literal -> BoolLiteral .)
    LEQ             reduce using rule 47 (Literal -> BoolLiteral .)
    GEQ             reduce using rule 47 (Literal -> BoolLiteral .)
    LT              reduce using rule 47 (Literal -> BoolLiteral .)
    GT              reduce using rule 47 (Literal -> BoolLiteral .)
    EQ              reduce using rule 47 (Literal -> BoolLiteral .)
    NE              reduce using rule 47 (Literal -> BoolLiteral .)
    LBRACKET        reduce using rule 47 (Literal -> BoolLiteral .)
    RPAREN          reduce using rule 47 (Literal -> BoolLiteral .)
    LET             reduce using rule 47 (Literal -> BoolLiteral .)
    IF              reduce using rule 47 (Literal -> BoolLiteral .)
    FOR             reduce using rule 47 (Literal -> BoolLiteral .)
    WHILE           reduce using rule 47 (Literal -> BoolLiteral .)
    BREAK           reduce using rule 47 (Literal -> BoolLiteral .)
    RETURN          reduce using rule 47 (Literal -> BoolLiteral .)
    ;               reduce using rule 47 (Literal -> BoolLiteral .)
    LPAREN          reduce using rule 47 (Literal -> BoolLiteral .)
    ID              reduce using rule 47 (Literal -> BoolLiteral .)
    LBRACE          reduce using rule 47 (Literal -> BoolLiteral .)
    AMPERSAND       reduce using rule 47 (Literal -> BoolLiteral .)
    INTL            reduce using rule 47 (Literal -> BoolLiteral .)
    BOOLL           reduce using rule 47 (Literal -> BoolLiteral .)
    RBRACE          reduce using rule 47 (Literal -> BoolLiteral .)
    RBRACKET        reduce using rule 47 (Literal -> BoolLiteral .)
    COMMA           reduce using rule 47 (Literal -> BoolLiteral .)


state 91

    (1) AddressExpression -> AMPERSAND . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 127
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 92

    (22) BoolLiteral -> BOOLL .

    SEMICOLON       reduce using rule 22 (BoolLiteral -> BOOLL .)
    ASSIGNMENT      reduce using rule 22 (BoolLiteral -> BOOLL .)
    PLUS            reduce using rule 22 (BoolLiteral -> BOOLL .)
    MINUS           reduce using rule 22 (BoolLiteral -> BOOLL .)
    TIMES           reduce using rule 22 (BoolLiteral -> BOOLL .)
    DIVIDE          reduce using rule 22 (BoolLiteral -> BOOLL .)
    MOD             reduce using rule 22 (BoolLiteral -> BOOLL .)
    LEQ             reduce using rule 22 (BoolLiteral -> BOOLL .)
    GEQ             reduce using rule 22 (BoolLiteral -> BOOLL .)
    LT              reduce using rule 22 (BoolLiteral -> BOOLL .)
    GT              reduce using rule 22 (BoolLiteral -> BOOLL .)
    EQ              reduce using rule 22 (BoolLiteral -> BOOLL .)
    NE              reduce using rule 22 (BoolLiteral -> BOOLL .)
    LBRACKET        reduce using rule 22 (BoolLiteral -> BOOLL .)
    RPAREN          reduce using rule 22 (BoolLiteral -> BOOLL .)
    LET             reduce using rule 22 (BoolLiteral -> BOOLL .)
    IF              reduce using rule 22 (BoolLiteral -> BOOLL .)
    FOR             reduce using rule 22 (BoolLiteral -> BOOLL .)
    WHILE           reduce using rule 22 (BoolLiteral -> BOOLL .)
    BREAK           reduce using rule 22 (BoolLiteral -> BOOLL .)
    RETURN          reduce using rule 22 (BoolLiteral -> BOOLL .)
    ;               reduce using rule 22 (BoolLiteral -> BOOLL .)
    LPAREN          reduce using rule 22 (BoolLiteral -> BOOLL .)
    ID              reduce using rule 22 (BoolLiteral -> BOOLL .)
    LBRACE          reduce using rule 22 (BoolLiteral -> BOOLL .)
    AMPERSAND       reduce using rule 22 (BoolLiteral -> BOOLL .)
    INTL            reduce using rule 22 (BoolLiteral -> BOOLL .)
    BOOLL           reduce using rule 22 (BoolLiteral -> BOOLL .)
    RBRACE          reduce using rule 22 (BoolLiteral -> BOOLL .)
    RBRACKET        reduce using rule 22 (BoolLiteral -> BOOLL .)
    COMMA           reduce using rule 22 (BoolLiteral -> BOOLL .)


state 93

    (38) FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR . RPAREN Block

    RPAREN          shift and go to state 128


state 94

    (69) StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR . RBRACE

    RBRACE          shift and go to state 129


state 95

    (74) Type -> ID LT TypeArgumentListR GT PointerListR .

    ID              reduce using rule 74 (Type -> ID LT TypeArgumentListR GT PointerListR .)
    COMMA           reduce using rule 74 (Type -> ID LT TypeArgumentListR GT PointerListR .)
    GT              reduce using rule 74 (Type -> ID LT TypeArgumentListR GT PointerListR .)


state 96

    (75) TypeArgumentListR -> Type COMMA TypeArgumentListR .

    GT              reduce using rule 75 (TypeArgumentListR -> Type COMMA TypeArgumentListR .)


state 97

    (20) Block -> LBRACE StatementListR RBRACE .

    FN              reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    STRUCT          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    $end            reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    LET             reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    IF              reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    FOR             reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    WHILE           reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    BREAK           reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    RETURN          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    ;               reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    LPAREN          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    ID              reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    LBRACE          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    TIMES           reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    AMPERSAND       reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    INTL            reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    BOOLL           reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    RBRACE          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    ELSE            reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)
    RPAREN          reduce using rule 20 (Block -> LBRACE StatementListR RBRACE .)


state 98

    (66) StatementListR -> Statement StatementListR .

    RBRACE          reduce using rule 66 (StatementListR -> Statement StatementListR .)


state 99

    (58) Statement -> Expression SEMICOLON .

    LET             reduce using rule 58 (Statement -> Expression SEMICOLON .)
    IF              reduce using rule 58 (Statement -> Expression SEMICOLON .)
    FOR             reduce using rule 58 (Statement -> Expression SEMICOLON .)
    WHILE           reduce using rule 58 (Statement -> Expression SEMICOLON .)
    BREAK           reduce using rule 58 (Statement -> Expression SEMICOLON .)
    RETURN          reduce using rule 58 (Statement -> Expression SEMICOLON .)
    ;               reduce using rule 58 (Statement -> Expression SEMICOLON .)
    LPAREN          reduce using rule 58 (Statement -> Expression SEMICOLON .)
    ID              reduce using rule 58 (Statement -> Expression SEMICOLON .)
    LBRACE          reduce using rule 58 (Statement -> Expression SEMICOLON .)
    TIMES           reduce using rule 58 (Statement -> Expression SEMICOLON .)
    AMPERSAND       reduce using rule 58 (Statement -> Expression SEMICOLON .)
    INTL            reduce using rule 58 (Statement -> Expression SEMICOLON .)
    BOOLL           reduce using rule 58 (Statement -> Expression SEMICOLON .)
    RBRACE          reduce using rule 58 (Statement -> Expression SEMICOLON .)
    RPAREN          reduce using rule 58 (Statement -> Expression SEMICOLON .)


state 100

    (6) AssignmentStatement -> Expression ASSIGNMENT . Expression SEMICOLON
    (7) AssignmentStatement -> Expression ASSIGNMENT . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 130
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 101

    (8) BinaryExpression -> Expression PLUS . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 131
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 102

    (9) BinaryExpression -> Expression MINUS . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 132
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 103

    (10) BinaryExpression -> Expression TIMES . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 133
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 104

    (11) BinaryExpression -> Expression DIVIDE . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 134
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 105

    (12) BinaryExpression -> Expression MOD . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 135
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 106

    (13) BinaryExpression -> Expression LEQ . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 136
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 107

    (14) BinaryExpression -> Expression GEQ . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 137
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 108

    (15) BinaryExpression -> Expression LT . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 138
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 109

    (16) BinaryExpression -> Expression GT . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 139
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 110

    (17) BinaryExpression -> Expression EQ . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 140
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 111

    (18) BinaryExpression -> Expression NE . Expression
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 141
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 112

    (23) BracketCall -> Expression LBRACKET . Expression RBRACKET
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 142
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 113

    (44) InitStatement -> LET ID . ASSIGNMENT InitCall SEMICOLON

    ASSIGNMENT      shift and go to state 143


state 114

    (35) FunctionCall -> ID LPAREN . ArgumentListR RPAREN
    (3) ArgumentListR -> . Argument COMMA ArgumentListR
    (4) ArgumentListR -> . Argument
    (5) ArgumentListR -> . empty
    (2) Argument -> . Expression
    (89) empty -> .
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RPAREN          reduce using rule 89 (empty -> .)
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    ArgumentListR                  shift and go to state 144
    Argument                       shift and go to state 145
    empty                          shift and go to state 146
    Expression                     shift and go to state 147
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 115

    (36) FunctionCall -> ID LT . TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (43) InitCall -> ID LT . TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (75) TypeArgumentListR -> . Type COMMA TypeArgumentListR
    (76) TypeArgumentListR -> . Type
    (77) TypeArgumentListR -> . empty
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR
    (89) empty -> .

    ID              shift and go to state 16
    GT              reduce using rule 89 (empty -> .)

    TypeArgumentListR              shift and go to state 148
    Type                           shift and go to state 43
    empty                          shift and go to state 44

state 116

    (42) InitCall -> ID LBRACE . ArgumentListR RBRACE
    (3) ArgumentListR -> . Argument COMMA ArgumentListR
    (4) ArgumentListR -> . Argument
    (5) ArgumentListR -> . empty
    (2) Argument -> . Expression
    (89) empty -> .
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RBRACE          reduce using rule 89 (empty -> .)
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    ArgumentListR                  shift and go to state 149
    Argument                       shift and go to state 145
    empty                          shift and go to state 146
    Expression                     shift and go to state 147
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 117

    (40) IdExpression -> IdExpression DOT . ID

    ID              shift and go to state 150


state 118

    (41) IfElseStatement -> IF LPAREN . Expression RPAREN Block ELSE Block
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 151
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 119

    (85) UnaryExpression -> LPAREN Expression . RPAREN
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    RPAREN          shift and go to state 152
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 120

    (34) ForStatement -> FOR LPAREN . Statement Expression SEMICOLON Statement RPAREN Block
    (56) Statement -> . AssignmentStatement
    (57) Statement -> . InitStatement
    (58) Statement -> . Expression SEMICOLON
    (59) Statement -> . IfElseStatement
    (60) Statement -> . ForStatement
    (61) Statement -> . WhileStatement
    (62) Statement -> . BreakStatement
    (63) Statement -> . ReturnStatement
    (64) Statement -> . BlockStatement
    (65) Statement -> . BlankStatement
    (6) AssignmentStatement -> . Expression ASSIGNMENT Expression SEMICOLON
    (7) AssignmentStatement -> . Expression ASSIGNMENT Expression
    (44) InitStatement -> . LET ID ASSIGNMENT InitCall SEMICOLON
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (41) IfElseStatement -> . IF LPAREN Expression RPAREN Block ELSE Block
    (34) ForStatement -> . FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block
    (88) WhileStatement -> . WHILE LPAREN Expression RPAREN Block
    (24) BreakStatement -> . BREAK INTL SEMICOLON
    (25) BreakStatement -> . BREAK SEMICOLON
    (54) ReturnStatement -> . RETURN Expression SEMICOLON
    (55) ReturnStatement -> . RETURN SEMICOLON
    (21) BlockStatement -> . Block
    (19) BlankStatement -> . ;
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (20) Block -> . LBRACE StatementListR RBRACE
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LET             shift and go to state 68
    IF              shift and go to state 74
    FOR             shift and go to state 77
    WHILE           shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 81
    ;               shift and go to state 82
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    LBRACE          shift and go to state 47
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Statement                      shift and go to state 153
    Expression                     shift and go to state 60
    Block                          shift and go to state 76
    AssignmentStatement            shift and go to state 58
    InitStatement                  shift and go to state 59
    IfElseStatement                shift and go to state 61
    ForStatement                   shift and go to state 62
    WhileStatement                 shift and go to state 63
    BreakStatement                 shift and go to state 64
    ReturnStatement                shift and go to state 65
    BlockStatement                 shift and go to state 66
    BlankStatement                 shift and go to state 67
    InitCall                       shift and go to state 70
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 121

    (88) WhileStatement -> WHILE LPAREN . Expression RPAREN Block
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 154
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 122

    (24) BreakStatement -> BREAK INTL . SEMICOLON

    SEMICOLON       shift and go to state 155


state 123

    (25) BreakStatement -> BREAK SEMICOLON .

    LET             reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    IF              reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    FOR             reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    ;               reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    ID              reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    TIMES           reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    AMPERSAND       reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    INTL            reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    BOOLL           reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)
    RPAREN          reduce using rule 25 (BreakStatement -> BREAK SEMICOLON .)


state 124

    (54) ReturnStatement -> RETURN Expression . SEMICOLON
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       shift and go to state 156
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 125

    (55) ReturnStatement -> RETURN SEMICOLON .

    LET             reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    IF              reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    FOR             reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    BREAK           reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    ;               reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    ID              reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    TIMES           reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    AMPERSAND       reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    INTL            reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    BOOLL           reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)
    RPAREN          reduce using rule 55 (ReturnStatement -> RETURN SEMICOLON .)


state 126

    (30) DereferenceExpression -> TIMES Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    ASSIGNMENT      reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    PLUS            reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    MINUS           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    TIMES           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    DIVIDE          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    MOD             reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    LBRACKET        reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    RPAREN          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    LET             reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    IF              reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    FOR             reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    WHILE           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    BREAK           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    RETURN          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    ;               reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    LPAREN          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    ID              reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    LBRACE          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    AMPERSAND       reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    INTL            reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    BOOLL           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    RBRACE          reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    RBRACKET        reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    COMMA           reduce using rule 30 (DereferenceExpression -> TIMES Expression .)
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! LEQ             [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! GEQ             [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! LT              [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! GT              [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! EQ              [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! NE              [ reduce using rule 30 (DereferenceExpression -> TIMES Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 127

    (1) AddressExpression -> AMPERSAND Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    SEMICOLON       reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    ASSIGNMENT      reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    RPAREN          reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    LET             reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    IF              reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    FOR             reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    WHILE           reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    BREAK           reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    RETURN          reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    ;               reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    LPAREN          reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    ID              reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    LBRACE          reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    AMPERSAND       reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    INTL            reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    BOOLL           reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    RBRACE          reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    RBRACKET        reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    COMMA           reduce using rule 1 (AddressExpression -> AMPERSAND Expression .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112

  ! PLUS            [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! MINUS           [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! TIMES           [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! DIVIDE          [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! MOD             [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! LEQ             [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! GEQ             [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! LT              [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! GT              [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! EQ              [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! NE              [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]
  ! LBRACKET        [ reduce using rule 1 (AddressExpression -> AMPERSAND Expression .) ]


state 128

    (38) FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN . Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 157

state 129

    (69) StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE .

    FN              reduce using rule 69 (StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE .)
    STRUCT          reduce using rule 69 (StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE .)
    $end            reduce using rule 69 (StructDefinition -> STRUCT ID LT TypeParameterListR GT LBRACE StructMemberListR RBRACE .)


state 130

    (6) AssignmentStatement -> Expression ASSIGNMENT Expression . SEMICOLON
    (7) AssignmentStatement -> Expression ASSIGNMENT Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

  ! shift/reduce conflict for TIMES resolved as shift
    SEMICOLON       shift and go to state 158
    LET             reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    IF              reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    FOR             reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    WHILE           reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    BREAK           reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    RETURN          reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    ;               reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    LPAREN          reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    ID              reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    LBRACE          reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    AMPERSAND       reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    INTL            reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    BOOLL           reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    RBRACE          reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    RPAREN          reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112

  ! TIMES           [ reduce using rule 7 (AssignmentStatement -> Expression ASSIGNMENT Expression .) ]


state 131

    (8) BinaryExpression -> Expression PLUS Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    ASSIGNMENT      reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    PLUS            reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    MINUS           reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    LBRACKET        reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    RPAREN          reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    LET             reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    IF              reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    FOR             reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    WHILE           reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    BREAK           reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    RETURN          reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    ;               reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    LPAREN          reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    ID              reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    LBRACE          reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    AMPERSAND       reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    INTL            reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    BOOLL           reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    RBRACE          reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    RBRACKET        reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    COMMA           reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .)
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! TIMES           [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! DIVIDE          [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! MOD             [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! LEQ             [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! GEQ             [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! LT              [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! GT              [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! EQ              [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! NE              [ reduce using rule 8 (BinaryExpression -> Expression PLUS Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 132

    (9) BinaryExpression -> Expression MINUS Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    ASSIGNMENT      reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    PLUS            reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    MINUS           reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    LBRACKET        reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    RPAREN          reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    LET             reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    IF              reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    FOR             reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    WHILE           reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    BREAK           reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    RETURN          reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    ;               reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    LPAREN          reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    ID              reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    LBRACE          reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    AMPERSAND       reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    INTL            reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    BOOLL           reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    RBRACE          reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    RBRACKET        reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    COMMA           reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .)
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! TIMES           [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! DIVIDE          [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! MOD             [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! LEQ             [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! GEQ             [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! LT              [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! GT              [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! EQ              [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! NE              [ reduce using rule 9 (BinaryExpression -> Expression MINUS Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 133

    (10) BinaryExpression -> Expression TIMES Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    ASSIGNMENT      reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    PLUS            reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    MINUS           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    TIMES           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    DIVIDE          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    MOD             reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    LBRACKET        reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    RPAREN          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    LET             reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    IF              reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    FOR             reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    WHILE           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    BREAK           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    RETURN          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    ;               reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    LPAREN          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    ID              reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    LBRACE          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    AMPERSAND       reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    INTL            reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    BOOLL           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    RBRACE          reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    RBRACKET        reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    COMMA           reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .)
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! LEQ             [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! GEQ             [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! LT              [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! GT              [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! EQ              [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! NE              [ reduce using rule 10 (BinaryExpression -> Expression TIMES Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 134

    (11) BinaryExpression -> Expression DIVIDE Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    ASSIGNMENT      reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    PLUS            reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    MINUS           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    TIMES           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    DIVIDE          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    MOD             reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    LBRACKET        reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    RPAREN          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    LET             reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    IF              reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    FOR             reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    WHILE           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    BREAK           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    RETURN          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    ;               reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    LPAREN          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    ID              reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    LBRACE          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    AMPERSAND       reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    INTL            reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    BOOLL           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    RBRACE          reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    RBRACKET        reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    COMMA           reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .)
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! LEQ             [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! GEQ             [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! LT              [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! GT              [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! EQ              [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! NE              [ reduce using rule 11 (BinaryExpression -> Expression DIVIDE Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 135

    (12) BinaryExpression -> Expression MOD Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    ASSIGNMENT      reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    PLUS            reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    MINUS           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    TIMES           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    DIVIDE          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    MOD             reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    LBRACKET        reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    RPAREN          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    LET             reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    IF              reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    FOR             reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    WHILE           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    BREAK           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    RETURN          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    ;               reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    LPAREN          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    ID              reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    LBRACE          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    AMPERSAND       reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    INTL            reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    BOOLL           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    RBRACE          reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    RBRACKET        reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    COMMA           reduce using rule 12 (BinaryExpression -> Expression MOD Expression .)
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111

  ! LEQ             [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! GEQ             [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! LT              [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! GT              [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! EQ              [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! NE              [ reduce using rule 12 (BinaryExpression -> Expression MOD Expression .) ]
  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 136

    (13) BinaryExpression -> Expression LEQ Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    ASSIGNMENT      reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    PLUS            reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    MINUS           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    TIMES           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    DIVIDE          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    MOD             reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LEQ             reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    GEQ             reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LT              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    GT              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    EQ              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    NE              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LBRACKET        reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    RPAREN          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LET             reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    IF              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    FOR             reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    WHILE           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    BREAK           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    RETURN          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    ;               reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LPAREN          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    ID              reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    LBRACE          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    AMPERSAND       reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    INTL            reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    BOOLL           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    RBRACE          reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    RBRACKET        reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)
    COMMA           reduce using rule 13 (BinaryExpression -> Expression LEQ Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 137

    (14) BinaryExpression -> Expression GEQ Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    ASSIGNMENT      reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    PLUS            reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    MINUS           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    TIMES           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    DIVIDE          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    MOD             reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LEQ             reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    GEQ             reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LT              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    GT              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    EQ              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    NE              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LBRACKET        reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    RPAREN          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LET             reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    IF              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    FOR             reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    WHILE           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    BREAK           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    RETURN          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    ;               reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LPAREN          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    ID              reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    LBRACE          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    AMPERSAND       reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    INTL            reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    BOOLL           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    RBRACE          reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    RBRACKET        reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)
    COMMA           reduce using rule 14 (BinaryExpression -> Expression GEQ Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 138

    (15) BinaryExpression -> Expression LT Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    ASSIGNMENT      reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    PLUS            reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    MINUS           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    TIMES           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    DIVIDE          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    MOD             reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LEQ             reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    GEQ             reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LT              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    GT              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    EQ              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    NE              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LBRACKET        reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    RPAREN          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LET             reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    IF              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    FOR             reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    WHILE           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    BREAK           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    RETURN          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    ;               reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LPAREN          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    ID              reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    LBRACE          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    AMPERSAND       reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    INTL            reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    BOOLL           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    RBRACE          reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    RBRACKET        reduce using rule 15 (BinaryExpression -> Expression LT Expression .)
    COMMA           reduce using rule 15 (BinaryExpression -> Expression LT Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 139

    (16) BinaryExpression -> Expression GT Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    ASSIGNMENT      reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    PLUS            reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    MINUS           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    TIMES           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    DIVIDE          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    MOD             reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LEQ             reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    GEQ             reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LT              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    GT              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    EQ              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    NE              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LBRACKET        reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    RPAREN          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LET             reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    IF              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    FOR             reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    WHILE           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    BREAK           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    RETURN          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    ;               reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LPAREN          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    ID              reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    LBRACE          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    AMPERSAND       reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    INTL            reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    BOOLL           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    RBRACE          reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    RBRACKET        reduce using rule 16 (BinaryExpression -> Expression GT Expression .)
    COMMA           reduce using rule 16 (BinaryExpression -> Expression GT Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 140

    (17) BinaryExpression -> Expression EQ Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    ASSIGNMENT      reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    PLUS            reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    MINUS           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    TIMES           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    DIVIDE          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    MOD             reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LEQ             reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    GEQ             reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LT              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    GT              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    EQ              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    NE              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LBRACKET        reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    RPAREN          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LET             reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    IF              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    FOR             reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    WHILE           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    BREAK           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    RETURN          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    ;               reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LPAREN          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    ID              reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    LBRACE          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    AMPERSAND       reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    INTL            reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    BOOLL           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    RBRACE          reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    RBRACKET        reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)
    COMMA           reduce using rule 17 (BinaryExpression -> Expression EQ Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 141

    (18) BinaryExpression -> Expression NE Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    ASSIGNMENT      reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    PLUS            reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    MINUS           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    TIMES           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    DIVIDE          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    MOD             reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LEQ             reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    GEQ             reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LT              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    GT              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    EQ              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    NE              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LBRACKET        reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    RPAREN          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LET             reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    IF              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    FOR             reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    WHILE           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    BREAK           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    RETURN          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    ;               reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LPAREN          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    ID              reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    LBRACE          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    AMPERSAND       reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    INTL            reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    BOOLL           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    RBRACE          reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    RBRACKET        reduce using rule 18 (BinaryExpression -> Expression NE Expression .)
    COMMA           reduce using rule 18 (BinaryExpression -> Expression NE Expression .)

  ! PLUS            [ shift and go to state 101 ]
  ! MINUS           [ shift and go to state 102 ]
  ! TIMES           [ shift and go to state 103 ]
  ! DIVIDE          [ shift and go to state 104 ]
  ! MOD             [ shift and go to state 105 ]
  ! LEQ             [ shift and go to state 106 ]
  ! GEQ             [ shift and go to state 107 ]
  ! LT              [ shift and go to state 108 ]
  ! GT              [ shift and go to state 109 ]
  ! EQ              [ shift and go to state 110 ]
  ! NE              [ shift and go to state 111 ]
  ! LBRACKET        [ shift and go to state 112 ]


state 142

    (23) BracketCall -> Expression LBRACKET Expression . RBRACKET
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    RBRACKET        shift and go to state 159
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 143

    (44) InitStatement -> LET ID ASSIGNMENT . InitCall SEMICOLON
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE

    ID              shift and go to state 160

    InitCall                       shift and go to state 161

state 144

    (35) FunctionCall -> ID LPAREN ArgumentListR . RPAREN

    RPAREN          shift and go to state 162


state 145

    (3) ArgumentListR -> Argument . COMMA ArgumentListR
    (4) ArgumentListR -> Argument .

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 4 (ArgumentListR -> Argument .)
    RBRACE          reduce using rule 4 (ArgumentListR -> Argument .)


state 146

    (5) ArgumentListR -> empty .

    RPAREN          reduce using rule 5 (ArgumentListR -> empty .)
    RBRACE          reduce using rule 5 (ArgumentListR -> empty .)


state 147

    (2) Argument -> Expression .
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    COMMA           reduce using rule 2 (Argument -> Expression .)
    RPAREN          reduce using rule 2 (Argument -> Expression .)
    RBRACE          reduce using rule 2 (Argument -> Expression .)
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 148

    (36) FunctionCall -> ID LT TypeArgumentListR . GT LPAREN ArgumentListR RPAREN
    (43) InitCall -> ID LT TypeArgumentListR . GT LBRACE ArgumentListR RBRACE

    GT              shift and go to state 164


state 149

    (42) InitCall -> ID LBRACE ArgumentListR . RBRACE

    RBRACE          shift and go to state 165


state 150

    (40) IdExpression -> IdExpression DOT ID .

    DOT             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    SEMICOLON       reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    ASSIGNMENT      reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    PLUS            reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    MINUS           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    TIMES           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    DIVIDE          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    MOD             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LEQ             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    GEQ             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LT              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    GT              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    EQ              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    NE              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LBRACKET        reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    RPAREN          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LET             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    IF              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    FOR             reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    WHILE           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    BREAK           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    RETURN          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    ;               reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LPAREN          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    ID              reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    LBRACE          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    AMPERSAND       reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    INTL            reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    BOOLL           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    RBRACE          reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    RBRACKET        reduce using rule 40 (IdExpression -> IdExpression DOT ID .)
    COMMA           reduce using rule 40 (IdExpression -> IdExpression DOT ID .)


state 151

    (41) IfElseStatement -> IF LPAREN Expression . RPAREN Block ELSE Block
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    RPAREN          shift and go to state 166
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 152

    (85) UnaryExpression -> LPAREN Expression RPAREN .

    SEMICOLON       reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    ASSIGNMENT      reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    PLUS            reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    MINUS           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    TIMES           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    DIVIDE          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    MOD             reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LEQ             reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    GEQ             reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LT              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    GT              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    EQ              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    NE              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LBRACKET        reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    RPAREN          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LET             reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    IF              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    FOR             reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    WHILE           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    BREAK           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    RETURN          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    ;               reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LPAREN          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    ID              reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    LBRACE          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    AMPERSAND       reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    INTL            reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    BOOLL           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    RBRACE          reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    RBRACKET        reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)
    COMMA           reduce using rule 85 (UnaryExpression -> LPAREN Expression RPAREN .)


state 153

    (34) ForStatement -> FOR LPAREN Statement . Expression SEMICOLON Statement RPAREN Block
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Expression                     shift and go to state 167
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 154

    (88) WhileStatement -> WHILE LPAREN Expression . RPAREN Block
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    RPAREN          shift and go to state 168
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 155

    (24) BreakStatement -> BREAK INTL SEMICOLON .

    LET             reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    IF              reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    FOR             reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    WHILE           reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    BREAK           reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    RETURN          reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    ;               reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    LPAREN          reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    ID              reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    LBRACE          reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    TIMES           reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    AMPERSAND       reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    INTL            reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    BOOLL           reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    RBRACE          reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)
    RPAREN          reduce using rule 24 (BreakStatement -> BREAK INTL SEMICOLON .)


state 156

    (54) ReturnStatement -> RETURN Expression SEMICOLON .

    LET             reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    IF              reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    FOR             reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    WHILE           reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    BREAK           reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    RETURN          reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    ;               reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    LPAREN          reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    ID              reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    LBRACE          reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    TIMES           reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    AMPERSAND       reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    INTL            reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    BOOLL           reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    RBRACE          reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)
    RPAREN          reduce using rule 54 (ReturnStatement -> RETURN Expression SEMICOLON .)


state 157

    (38) FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block .

    FN              reduce using rule 38 (FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block .)
    STRUCT          reduce using rule 38 (FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block .)
    $end            reduce using rule 38 (FunctionDefinition -> FN ID LT TypeParameterListR GT LPAREN ParameterListR RPAREN Block .)


state 158

    (6) AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .

    LET             reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    IF              reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    FOR             reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    WHILE           reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    BREAK           reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    RETURN          reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    ;               reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    LPAREN          reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    ID              reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    LBRACE          reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    TIMES           reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    AMPERSAND       reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    INTL            reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    BOOLL           reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    RBRACE          reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)
    RPAREN          reduce using rule 6 (AssignmentStatement -> Expression ASSIGNMENT Expression SEMICOLON .)


state 159

    (23) BracketCall -> Expression LBRACKET Expression RBRACKET .

    SEMICOLON       reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    ASSIGNMENT      reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    PLUS            reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    MINUS           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    TIMES           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    DIVIDE          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    MOD             reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LEQ             reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    GEQ             reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LT              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    GT              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    EQ              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    NE              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LBRACKET        reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    RPAREN          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LET             reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    IF              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    FOR             reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    WHILE           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    BREAK           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    RETURN          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    ;               reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LPAREN          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    ID              reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    LBRACE          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    AMPERSAND       reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    INTL            reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    BOOLL           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    RBRACE          reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    RBRACKET        reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)
    COMMA           reduce using rule 23 (BracketCall -> Expression LBRACKET Expression RBRACKET .)


state 160

    (42) InitCall -> ID . LBRACE ArgumentListR RBRACE
    (43) InitCall -> ID . LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE

    LBRACE          shift and go to state 116
    LT              shift and go to state 169


state 161

    (44) InitStatement -> LET ID ASSIGNMENT InitCall . SEMICOLON

    SEMICOLON       shift and go to state 170


state 162

    (35) FunctionCall -> ID LPAREN ArgumentListR RPAREN .

    SEMICOLON       reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    ASSIGNMENT      reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    PLUS            reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    MINUS           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    TIMES           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    DIVIDE          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    MOD             reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LEQ             reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    GEQ             reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LT              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    GT              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    EQ              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    NE              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LBRACKET        reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    RPAREN          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LET             reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    IF              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    FOR             reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    WHILE           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    BREAK           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    RETURN          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    ;               reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LPAREN          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    ID              reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    LBRACE          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    AMPERSAND       reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    INTL            reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    BOOLL           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    RBRACE          reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    RBRACKET        reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)
    COMMA           reduce using rule 35 (FunctionCall -> ID LPAREN ArgumentListR RPAREN .)


state 163

    (3) ArgumentListR -> Argument COMMA . ArgumentListR
    (3) ArgumentListR -> . Argument COMMA ArgumentListR
    (4) ArgumentListR -> . Argument
    (5) ArgumentListR -> . empty
    (2) Argument -> . Expression
    (89) empty -> .
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RPAREN          reduce using rule 89 (empty -> .)
    RBRACE          reduce using rule 89 (empty -> .)
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Argument                       shift and go to state 145
    ArgumentListR                  shift and go to state 171
    empty                          shift and go to state 146
    Expression                     shift and go to state 147
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 164

    (36) FunctionCall -> ID LT TypeArgumentListR GT . LPAREN ArgumentListR RPAREN
    (43) InitCall -> ID LT TypeArgumentListR GT . LBRACE ArgumentListR RBRACE

    LPAREN          shift and go to state 172
    LBRACE          shift and go to state 173


state 165

    (42) InitCall -> ID LBRACE ArgumentListR RBRACE .

    SEMICOLON       reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    ASSIGNMENT      reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    PLUS            reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    MINUS           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    TIMES           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    DIVIDE          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    MOD             reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LEQ             reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    GEQ             reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LT              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    GT              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    EQ              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    NE              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LBRACKET        reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    RPAREN          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LET             reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    IF              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    FOR             reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    WHILE           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    BREAK           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    RETURN          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    ;               reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LPAREN          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    ID              reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    LBRACE          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    AMPERSAND       reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    INTL            reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    BOOLL           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    RBRACE          reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    RBRACKET        reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)
    COMMA           reduce using rule 42 (InitCall -> ID LBRACE ArgumentListR RBRACE .)


state 166

    (41) IfElseStatement -> IF LPAREN Expression RPAREN . Block ELSE Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 174

state 167

    (34) ForStatement -> FOR LPAREN Statement Expression . SEMICOLON Statement RPAREN Block
    (8) BinaryExpression -> Expression . PLUS Expression
    (9) BinaryExpression -> Expression . MINUS Expression
    (10) BinaryExpression -> Expression . TIMES Expression
    (11) BinaryExpression -> Expression . DIVIDE Expression
    (12) BinaryExpression -> Expression . MOD Expression
    (13) BinaryExpression -> Expression . LEQ Expression
    (14) BinaryExpression -> Expression . GEQ Expression
    (15) BinaryExpression -> Expression . LT Expression
    (16) BinaryExpression -> Expression . GT Expression
    (17) BinaryExpression -> Expression . EQ Expression
    (18) BinaryExpression -> Expression . NE Expression
    (23) BracketCall -> Expression . LBRACKET Expression RBRACKET

    SEMICOLON       shift and go to state 175
    PLUS            shift and go to state 101
    MINUS           shift and go to state 102
    TIMES           shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105
    LEQ             shift and go to state 106
    GEQ             shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQ              shift and go to state 110
    NE              shift and go to state 111
    LBRACKET        shift and go to state 112


state 168

    (88) WhileStatement -> WHILE LPAREN Expression RPAREN . Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 176

state 169

    (43) InitCall -> ID LT . TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (75) TypeArgumentListR -> . Type COMMA TypeArgumentListR
    (76) TypeArgumentListR -> . Type
    (77) TypeArgumentListR -> . empty
    (73) Type -> . ID PointerListR
    (74) Type -> . ID LT TypeArgumentListR GT PointerListR
    (89) empty -> .

    ID              shift and go to state 16
    GT              reduce using rule 89 (empty -> .)

    TypeArgumentListR              shift and go to state 177
    Type                           shift and go to state 43
    empty                          shift and go to state 44

state 170

    (44) InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .

    LET             reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    IF              reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    FOR             reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    WHILE           reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    BREAK           reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    RETURN          reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    ;               reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    LPAREN          reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    ID              reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    LBRACE          reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    TIMES           reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    AMPERSAND       reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    INTL            reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    BOOLL           reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    RBRACE          reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)
    RPAREN          reduce using rule 44 (InitStatement -> LET ID ASSIGNMENT InitCall SEMICOLON .)


state 171

    (3) ArgumentListR -> Argument COMMA ArgumentListR .

    RPAREN          reduce using rule 3 (ArgumentListR -> Argument COMMA ArgumentListR .)
    RBRACE          reduce using rule 3 (ArgumentListR -> Argument COMMA ArgumentListR .)


state 172

    (36) FunctionCall -> ID LT TypeArgumentListR GT LPAREN . ArgumentListR RPAREN
    (3) ArgumentListR -> . Argument COMMA ArgumentListR
    (4) ArgumentListR -> . Argument
    (5) ArgumentListR -> . empty
    (2) Argument -> . Expression
    (89) empty -> .
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RPAREN          reduce using rule 89 (empty -> .)
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    ArgumentListR                  shift and go to state 178
    Argument                       shift and go to state 145
    empty                          shift and go to state 146
    Expression                     shift and go to state 147
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 173

    (43) InitCall -> ID LT TypeArgumentListR GT LBRACE . ArgumentListR RBRACE
    (3) ArgumentListR -> . Argument COMMA ArgumentListR
    (4) ArgumentListR -> . Argument
    (5) ArgumentListR -> . empty
    (2) Argument -> . Expression
    (89) empty -> .
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    RBRACE          reduce using rule 89 (empty -> .)
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    ArgumentListR                  shift and go to state 179
    Argument                       shift and go to state 145
    empty                          shift and go to state 146
    Expression                     shift and go to state 147
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    InitCall                       shift and go to state 70
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 174

    (41) IfElseStatement -> IF LPAREN Expression RPAREN Block . ELSE Block

    ELSE            shift and go to state 180


state 175

    (34) ForStatement -> FOR LPAREN Statement Expression SEMICOLON . Statement RPAREN Block
    (56) Statement -> . AssignmentStatement
    (57) Statement -> . InitStatement
    (58) Statement -> . Expression SEMICOLON
    (59) Statement -> . IfElseStatement
    (60) Statement -> . ForStatement
    (61) Statement -> . WhileStatement
    (62) Statement -> . BreakStatement
    (63) Statement -> . ReturnStatement
    (64) Statement -> . BlockStatement
    (65) Statement -> . BlankStatement
    (6) AssignmentStatement -> . Expression ASSIGNMENT Expression SEMICOLON
    (7) AssignmentStatement -> . Expression ASSIGNMENT Expression
    (44) InitStatement -> . LET ID ASSIGNMENT InitCall SEMICOLON
    (31) Expression -> . BinaryExpression
    (32) Expression -> . UnaryExpression
    (33) Expression -> . IdExpression
    (41) IfElseStatement -> . IF LPAREN Expression RPAREN Block ELSE Block
    (34) ForStatement -> . FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block
    (88) WhileStatement -> . WHILE LPAREN Expression RPAREN Block
    (24) BreakStatement -> . BREAK INTL SEMICOLON
    (25) BreakStatement -> . BREAK SEMICOLON
    (54) ReturnStatement -> . RETURN Expression SEMICOLON
    (55) ReturnStatement -> . RETURN SEMICOLON
    (21) BlockStatement -> . Block
    (19) BlankStatement -> . ;
    (8) BinaryExpression -> . Expression PLUS Expression
    (9) BinaryExpression -> . Expression MINUS Expression
    (10) BinaryExpression -> . Expression TIMES Expression
    (11) BinaryExpression -> . Expression DIVIDE Expression
    (12) BinaryExpression -> . Expression MOD Expression
    (13) BinaryExpression -> . Expression LEQ Expression
    (14) BinaryExpression -> . Expression GEQ Expression
    (15) BinaryExpression -> . Expression LT Expression
    (16) BinaryExpression -> . Expression GT Expression
    (17) BinaryExpression -> . Expression EQ Expression
    (18) BinaryExpression -> . Expression NE Expression
    (81) UnaryExpression -> . Literal
    (82) UnaryExpression -> . FunctionCall
    (83) UnaryExpression -> . BracketCall
    (84) UnaryExpression -> . InitCall
    (85) UnaryExpression -> . LPAREN Expression RPAREN
    (86) UnaryExpression -> . DereferenceExpression
    (87) UnaryExpression -> . AddressExpression
    (39) IdExpression -> . ID
    (40) IdExpression -> . IdExpression DOT ID
    (20) Block -> . LBRACE StatementListR RBRACE
    (46) Literal -> . IntLiteral
    (47) Literal -> . BoolLiteral
    (35) FunctionCall -> . ID LPAREN ArgumentListR RPAREN
    (36) FunctionCall -> . ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN
    (23) BracketCall -> . Expression LBRACKET Expression RBRACKET
    (42) InitCall -> . ID LBRACE ArgumentListR RBRACE
    (43) InitCall -> . ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE
    (30) DereferenceExpression -> . TIMES Expression
    (1) AddressExpression -> . AMPERSAND Expression
    (45) IntLiteral -> . INTL
    (22) BoolLiteral -> . BOOLL

    LET             shift and go to state 68
    IF              shift and go to state 74
    FOR             shift and go to state 77
    WHILE           shift and go to state 78
    BREAK           shift and go to state 79
    RETURN          shift and go to state 81
    ;               shift and go to state 82
    LPAREN          shift and go to state 75
    ID              shift and go to state 69
    LBRACE          shift and go to state 47
    TIMES           shift and go to state 83
    AMPERSAND       shift and go to state 91
    INTL            shift and go to state 80
    BOOLL           shift and go to state 92

    Statement                      shift and go to state 181
    Expression                     shift and go to state 60
    Block                          shift and go to state 76
    AssignmentStatement            shift and go to state 58
    InitStatement                  shift and go to state 59
    IfElseStatement                shift and go to state 61
    ForStatement                   shift and go to state 62
    WhileStatement                 shift and go to state 63
    BreakStatement                 shift and go to state 64
    ReturnStatement                shift and go to state 65
    BlockStatement                 shift and go to state 66
    BlankStatement                 shift and go to state 67
    InitCall                       shift and go to state 70
    BinaryExpression               shift and go to state 71
    UnaryExpression                shift and go to state 72
    IdExpression                   shift and go to state 73
    Literal                        shift and go to state 84
    FunctionCall                   shift and go to state 85
    BracketCall                    shift and go to state 86
    DereferenceExpression          shift and go to state 87
    AddressExpression              shift and go to state 88
    IntLiteral                     shift and go to state 89
    BoolLiteral                    shift and go to state 90

state 176

    (88) WhileStatement -> WHILE LPAREN Expression RPAREN Block .

    LET             reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    IF              reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    FOR             reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    WHILE           reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    BREAK           reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    RETURN          reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    ;               reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    LPAREN          reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    ID              reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    LBRACE          reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    TIMES           reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    AMPERSAND       reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    INTL            reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    BOOLL           reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    RBRACE          reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)
    RPAREN          reduce using rule 88 (WhileStatement -> WHILE LPAREN Expression RPAREN Block .)


state 177

    (43) InitCall -> ID LT TypeArgumentListR . GT LBRACE ArgumentListR RBRACE

    GT              shift and go to state 182


state 178

    (36) FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR . RPAREN

    RPAREN          shift and go to state 183


state 179

    (43) InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR . RBRACE

    RBRACE          shift and go to state 184


state 180

    (41) IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE . Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 185

state 181

    (34) ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement . RPAREN Block

    RPAREN          shift and go to state 186


state 182

    (43) InitCall -> ID LT TypeArgumentListR GT . LBRACE ArgumentListR RBRACE

    LBRACE          shift and go to state 173


state 183

    (36) FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .

    SEMICOLON       reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    ASSIGNMENT      reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    PLUS            reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    MINUS           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    TIMES           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    DIVIDE          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    MOD             reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LEQ             reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    GEQ             reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LT              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    GT              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    EQ              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    NE              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LBRACKET        reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    RPAREN          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LET             reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    IF              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    FOR             reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    WHILE           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    BREAK           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    RETURN          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    ;               reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LPAREN          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    ID              reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    LBRACE          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    AMPERSAND       reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    INTL            reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    BOOLL           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    RBRACE          reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    RBRACKET        reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)
    COMMA           reduce using rule 36 (FunctionCall -> ID LT TypeArgumentListR GT LPAREN ArgumentListR RPAREN .)


state 184

    (43) InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .

    SEMICOLON       reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    ASSIGNMENT      reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    PLUS            reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    MINUS           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    TIMES           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    DIVIDE          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    MOD             reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LEQ             reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    GEQ             reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LT              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    GT              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    EQ              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    NE              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LBRACKET        reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    RPAREN          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LET             reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    IF              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    FOR             reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    WHILE           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    BREAK           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    RETURN          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    ;               reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LPAREN          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    ID              reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    LBRACE          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    AMPERSAND       reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    INTL            reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    BOOLL           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    RBRACE          reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    RBRACKET        reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)
    COMMA           reduce using rule 43 (InitCall -> ID LT TypeArgumentListR GT LBRACE ArgumentListR RBRACE .)


state 185

    (41) IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .

    LET             reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    IF              reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    FOR             reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    WHILE           reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    BREAK           reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    RETURN          reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    ;               reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    LPAREN          reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    ID              reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    LBRACE          reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    TIMES           reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    AMPERSAND       reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    INTL            reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    BOOLL           reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    RBRACE          reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)
    RPAREN          reduce using rule 41 (IfElseStatement -> IF LPAREN Expression RPAREN Block ELSE Block .)


state 186

    (34) ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN . Block
    (20) Block -> . LBRACE StatementListR RBRACE

    LBRACE          shift and go to state 47

    Block                          shift and go to state 187

state 187

    (34) ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .

    LET             reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    IF              reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    FOR             reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    WHILE           reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    BREAK           reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    RETURN          reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    ;               reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    LPAREN          reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    ID              reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    LBRACE          reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    TIMES           reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    AMPERSAND       reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    INTL            reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    BOOLL           reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    RBRACE          reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)
    RPAREN          reduce using rule 34 (ForStatement -> FOR LPAREN Statement Expression SEMICOLON Statement RPAREN Block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 69 resolved as shift
WARNING: shift/reduce conflict for LT in state 69 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for MOD in state 127 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 127 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 127 resolved as shift
WARNING: shift/reduce conflict for LT in state 127 resolved as shift
WARNING: shift/reduce conflict for GT in state 127 resolved as shift
WARNING: shift/reduce conflict for EQ in state 127 resolved as shift
WARNING: shift/reduce conflict for NE in state 127 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 127 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 130 resolved as shift
