


---------------------
Program: examples/demo_cast.st

fn main() -> i32{
    let a = in<i32>();
    let b = cast<bool>(a);
    out(b);
}
---------------------

5
-1

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_check.st

fn main() -> i32{
    let b = 5i64;
    let a = heap_object<i64>(15i64);

    return 0;
}
---------------------


Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_fib_ct.st

//
// compile time computation example
//

struct fib<T> -> i1{
    type _ = enable_if<T == i1>;
}
struct fib<T> -> i1{
    type _ = enable_if<T == i2>;
}

struct fib<T> -> R{
    type _ = enable_if<T != i1>;
    type _ = enable_if<T != i2>;
    type R = fib<T-i1>+fib<T-i2>;
}

fn ct_fib<T>() -> i32{
    type f = fib<T>;
    let value = type_to_value<f, i32>();
    return value;
}

fn main() -> i32{
    let v = ct_fib<i10>();
    return v;
}
---------------------


Exit status: 55
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_fib_rt_loop.st

fn fib(n) -> i32{
    type _1 = enable_if<n==i32>;
    let f1 = 1;
    let f2 = 1;
    let fb = 0;

    for (n=n-1;n>!0; n=n-1;){
        fb = f2;
        f2 = f1 + f2;
        f1 = fb;
    }
    return f1;
}

fn main() -> i32{
    let n = in<i32>();
    let f = fib(n);
    out(f);
    return 0;
}
---------------------

10
55

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_fib_rt_rec.st

fn fib(n) -> i32{
    type _1 = enable_if<n==i32>;

    if (n<=2){
        return 1;
    }
    else{
        return fib(n-1)+fib(n-2);
    }
}

fn main() -> i32{
    let n = in<i32>();
    let f = fib(n);
    out(f);
    return 0;
}
---------------------

10
55

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_io.st

fn main() -> i32{
    let n = in<i32>();
    out(n+1);
    return 0;
}
---------------------

5
6

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_memory_init.st

struct rect<T>{
    let a = T;
    let b = T;
}

fn main() -> i32{
    let a = in<i32>();
    let b = in<i32>();

    type irect = rect<i32>;

    let rect_heap = heap_object<irect>(a,b);

    out(rect_heap!.a);
    out(rect_heap!.b);

    heap_free(rect_heap);
    out(rect_heap!.a);
    out(rect_heap!.b);
}
---------------------

10 20
10
20
882016226
21909

Exit status: 144
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_memory.st

fn printpos(ptr, pos){
    out(ptr[pos]!);
}

fn setpos(ptr, pos, val){
    ptr[pos]! = val;
}

fn main() -> i32{
    let A = heap_alloc<i32>(10);
    setpos(A, 3, 123);
    setpos(A, 6, 456);
    printpos(A, 3);
    printpos(A, 6);
    printpos(A, 5);
    heap_free(A);

    // B will sometimes be allocated exactly where A was, and overwrite its contents.
    // of course, this is a memory error, but it will probably continue without crashing.

    let B = heap_alloc<i32>(10);
    setpos(B, 3, 0);
    setpos(B, 6, 0);
    printpos(A, 3);
    printpos(A, 6);
    printpos(A, 5);

    return 0;
}
---------------------

123
456
0
0
0
0

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_rect.st

struct rectangle<T>{
    let a = T;
    let b = T;
}

fn area(r) -> T{
    type T = enable_if_resolve<r.T>;
    type _1 = enable_if<r==rectangle<T>>;

    return r.a * r.b;
}

fn main() -> i32{
    let a = in<i32>();
    let rec = object<rectangle<i32>>(a, 3);
    let ar = area(rec);
    out(ar);
    return 0;
}
---------------------

5
15

Exit status: 0
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_simple.st

fn main() -> i32{
    return 123;
}
---------------------


Exit status: 123
Press any key to continue
---------------------
======================
======================
======================



---------------------
Program: examples/demo_sptr.st

struct shared_ptr<T>{
    let item_ptr = @T;
    let count = @i32;
}

fn __init__(sptr_ptr, item_ptr){
    type T = enable_if_resolve<sptr_ptr!.T>;
    type _1 = enable_if<sptr_ptr == @shared_ptr<T>>;
    type _2 = enable_if<item_ptr == @T>;

    sptr_ptr!.item_ptr = item_ptr;
    sptr_ptr!.count = heap_object<i32>(1);
}

fn __dest__(sptr_ptr){
    type T = enable_if_resolve<sptr_ptr!.T>;
    type _1 = enable_if<sptr_ptr == @shared_ptr<T>>;

    sptr_ptr!.count! = sptr_ptr!.count! - 1;
    /*if (sptr_ptr!.count! == 1){
        heap_free<T>(sptr_ptr!.item_ptr);
        //heap_free<i32>(sptr_ptr!.count);
    }*/
}

fn __copy__(sptr_ptr_dest, sptr_ptr_src){
    type T = enable_if_resolve<sptr_ptr_dest!.T>;
    type _1 = enable_if<sptr_ptr_dest == @shared_ptr<T>>;
    type _2 = enable_if<sptr_ptr_src == @shared_ptr<T>>;

    sptr_ptr_src!.count! = sptr_ptr_src!.count! + 1;

    sptr_ptr_dest!.item_ptr = sptr_ptr_src!.item_ptr;
    sptr_ptr_dest!.count = sptr_ptr_src!.count;
}

fn main() -> i32{
    let a = object<shared_ptr<i8>>(heap_object<i8>(15i8));
    out(1000000);
    out(a.count!);
    out(a.item_ptr!);
    {
        let b = a;
        out(1000000);
        out(a.count!);
        out(a.item_ptr!);
        out(b.count!);
        out(b.item_ptr!);
        b.item_ptr! = 13i8;
        out(1000000);
        out(a.count!);
        out(a.item_ptr!);
        out(b.count!);
        out(b.item_ptr!);
    }
    out(1000000);
    out(a.count!);
    out(a.item_ptr!);

    return 0;
}
---------------------

1000000
1
15
1000000
2
15
2
15
1000000
2
13
2
13
1000000
1
13

Exit status: 0
Press any key to continue
---------------------
======================
======================
